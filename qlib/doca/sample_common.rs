//From /opt/mellanox/doca/samples/common.h
//By bindgen ./common.h  -o /home/cxyzhao/bf2-quark/Quark/sample_common.rs -- -I/opt/mellanox/doca/include
/* automatically generated by rust-bindgen 0.63.0 */

#[repr(C)]
#[derive(Copy, Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct __BindgenBitfieldUnit<Storage> {
    storage: Storage,
}
impl<Storage> __BindgenBitfieldUnit<Storage> {
    #[inline]
    pub const fn new(storage: Storage) -> Self {
        Self { storage }
    }
}
impl<Storage> __BindgenBitfieldUnit<Storage>
where
    Storage: AsRef<[u8]> + AsMut<[u8]>,
{
    #[inline]
    pub fn get_bit(&self, index: usize) -> bool {
        debug_assert!(index / 8 < self.storage.as_ref().len());
        let byte_index = index / 8;
        let byte = self.storage.as_ref()[byte_index];
        let bit_index = if cfg!(target_endian = "big") {
            7 - (index % 8)
        } else {
            index % 8
        };
        let mask = 1 << bit_index;
        byte & mask == mask
    }
    #[inline]
    pub fn set_bit(&mut self, index: usize, val: bool) {
        debug_assert!(index / 8 < self.storage.as_ref().len());
        let byte_index = index / 8;
        let byte = &mut self.storage.as_mut()[byte_index];
        let bit_index = if cfg!(target_endian = "big") {
            7 - (index % 8)
        } else {
            index % 8
        };
        let mask = 1 << bit_index;
        if val {
            *byte |= mask;
        } else {
            *byte &= !mask;
        }
    }
    #[inline]
    pub fn get(&self, bit_offset: usize, bit_width: u8) -> u64 {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());
        let mut val = 0;
        for i in 0..(bit_width as usize) {
            if self.get_bit(i + bit_offset) {
                let index = if cfg!(target_endian = "big") {
                    bit_width as usize - 1 - i
                } else {
                    i
                };
                val |= 1 << index;
            }
        }
        val
    }
    #[inline]
    pub fn set(&mut self, bit_offset: usize, bit_width: u8, val: u64) {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());
        for i in 0..(bit_width as usize) {
            let mask = 1 << i;
            let val_bit_is_set = val & mask == mask;
            let index = if cfg!(target_endian = "big") {
                bit_width as usize - 1 - i
            } else {
                i
            };
            self.set_bit(index + bit_offset, val_bit_is_set);
        }
    }
}
pub const _STRING_H: u32 = 1;
pub const _FEATURES_H: u32 = 1;
pub const _DEFAULT_SOURCE: u32 = 1;
pub const __GLIBC_USE_ISOC2X: u32 = 0;
pub const __USE_ISOC11: u32 = 1;
pub const __USE_ISOC99: u32 = 1;
pub const __USE_ISOC95: u32 = 1;
pub const __USE_POSIX_IMPLICITLY: u32 = 1;
pub const _POSIX_SOURCE: u32 = 1;
pub const _POSIX_C_SOURCE: u32 = 200809;
pub const __USE_POSIX: u32 = 1;
pub const __USE_POSIX2: u32 = 1;
pub const __USE_POSIX199309: u32 = 1;
pub const __USE_POSIX199506: u32 = 1;
pub const __USE_XOPEN2K: u32 = 1;
pub const __USE_XOPEN2K8: u32 = 1;
pub const _ATFILE_SOURCE: u32 = 1;
pub const __USE_MISC: u32 = 1;
pub const __USE_ATFILE: u32 = 1;
pub const __USE_FORTIFY_LEVEL: u32 = 0;
pub const __GLIBC_USE_DEPRECATED_GETS: u32 = 0;
pub const __GLIBC_USE_DEPRECATED_SCANF: u32 = 0;
pub const _STDC_PREDEF_H: u32 = 1;
pub const __STDC_IEC_559__: u32 = 1;
pub const __STDC_IEC_559_COMPLEX__: u32 = 1;
pub const __STDC_ISO_10646__: u32 = 201706;
pub const __GNU_LIBRARY__: u32 = 6;
pub const __GLIBC__: u32 = 2;
pub const __GLIBC_MINOR__: u32 = 31;
pub const _SYS_CDEFS_H: u32 = 1;
pub const __glibc_c99_flexarr_available: u32 = 1;
pub const __WORDSIZE: u32 = 64;
pub const __WORDSIZE_TIME64_COMPAT32: u32 = 1;
pub const __SYSCALL_WORDSIZE: u32 = 64;
pub const __LONG_DOUBLE_USES_FLOAT128: u32 = 0;
pub const __HAVE_GENERIC_SELECTION: u32 = 1;
pub const __GLIBC_USE_LIB_EXT2: u32 = 0;
pub const __GLIBC_USE_IEC_60559_BFP_EXT: u32 = 0;
pub const __GLIBC_USE_IEC_60559_BFP_EXT_C2X: u32 = 0;
pub const __GLIBC_USE_IEC_60559_FUNCS_EXT: u32 = 0;
pub const __GLIBC_USE_IEC_60559_FUNCS_EXT_C2X: u32 = 0;
pub const __GLIBC_USE_IEC_60559_TYPES_EXT: u32 = 0;
pub const _BITS_TYPES_LOCALE_T_H: u32 = 1;
pub const _BITS_TYPES___LOCALE_T_H: u32 = 1;
pub const _STRINGS_H: u32 = 1;
pub const _STDINT_H: u32 = 1;
pub const _BITS_TYPES_H: u32 = 1;
pub const __TIMESIZE: u32 = 64;
pub const _BITS_TYPESIZES_H: u32 = 1;
pub const __OFF_T_MATCHES_OFF64_T: u32 = 1;
pub const __INO_T_MATCHES_INO64_T: u32 = 1;
pub const __RLIM_T_MATCHES_RLIM64_T: u32 = 1;
pub const __STATFS_MATCHES_STATFS64: u32 = 1;
pub const __FD_SETSIZE: u32 = 1024;
pub const _BITS_TIME64_H: u32 = 1;
pub const _BITS_WCHAR_H: u32 = 1;
pub const _BITS_STDINT_INTN_H: u32 = 1;
pub const _BITS_STDINT_UINTN_H: u32 = 1;
pub const INT8_MIN: i32 = -128;
pub const INT16_MIN: i32 = -32768;
pub const INT32_MIN: i32 = -2147483648;
pub const INT8_MAX: u32 = 127;
pub const INT16_MAX: u32 = 32767;
pub const INT32_MAX: u32 = 2147483647;
pub const UINT8_MAX: u32 = 255;
pub const UINT16_MAX: u32 = 65535;
pub const UINT32_MAX: u32 = 4294967295;
pub const INT_LEAST8_MIN: i32 = -128;
pub const INT_LEAST16_MIN: i32 = -32768;
pub const INT_LEAST32_MIN: i32 = -2147483648;
pub const INT_LEAST8_MAX: u32 = 127;
pub const INT_LEAST16_MAX: u32 = 32767;
pub const INT_LEAST32_MAX: u32 = 2147483647;
pub const UINT_LEAST8_MAX: u32 = 255;
pub const UINT_LEAST16_MAX: u32 = 65535;
pub const UINT_LEAST32_MAX: u32 = 4294967295;
pub const INT_FAST8_MIN: i32 = -128;
pub const INT_FAST16_MIN: i64 = -9223372036854775808;
pub const INT_FAST32_MIN: i64 = -9223372036854775808;
pub const INT_FAST8_MAX: u32 = 127;
pub const INT_FAST16_MAX: u64 = 9223372036854775807;
pub const INT_FAST32_MAX: u64 = 9223372036854775807;
pub const UINT_FAST8_MAX: u32 = 255;
pub const UINT_FAST16_MAX: i32 = -1;
pub const UINT_FAST32_MAX: i32 = -1;
pub const INTPTR_MIN: i64 = -9223372036854775808;
pub const INTPTR_MAX: u64 = 9223372036854775807;
pub const UINTPTR_MAX: i32 = -1;
pub const PTRDIFF_MIN: i64 = -9223372036854775808;
pub const PTRDIFF_MAX: u64 = 9223372036854775807;
pub const SIG_ATOMIC_MIN: i32 = -2147483648;
pub const SIG_ATOMIC_MAX: u32 = 2147483647;
pub const SIZE_MAX: i32 = -1;
pub const WINT_MIN: u32 = 0;
pub const WINT_MAX: u32 = 4294967295;
pub const DOCA_VER_MAJOR: u32 = 1;
pub const DOCA_VER_MINOR: u32 = 5;
pub const DOCA_VER_PATCH: u32 = 55;
pub const DOCA_VER_STRING: &[u8; 9usize] = b"1.5.0055\0";
pub const doca_event_invalid_handle: i32 = -1;
pub const PCI_FUNCTION_MAX_VALUE: u32 = 8;
pub const PCI_DEVICE_MAX_VALUE: u32 = 32;
pub const PCI_BUS_MAX_VALUE: u32 = 256;
pub const DOCA_DEVINFO_VUID_SIZE: u32 = 128;
pub const DOCA_DEVINFO_IPV4_ADDR_SIZE: u32 = 4;
pub const DOCA_DEVINFO_IPV6_ADDR_SIZE: u32 = 16;
pub const DOCA_DEVINFO_IFACE_NAME_SIZE: u32 = 256;
pub const DOCA_DEVINFO_IBDEV_NAME_SIZE: u32 = 64;
pub const DOCA_DEVINFO_REP_VUID_SIZE: u32 = 128;
extern "C" {
    pub fn memcpy(
        __dest: *mut ::std::os::raw::c_void,
        __src: *const ::std::os::raw::c_void,
        __n: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn memmove(
        __dest: *mut ::std::os::raw::c_void,
        __src: *const ::std::os::raw::c_void,
        __n: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn memccpy(
        __dest: *mut ::std::os::raw::c_void,
        __src: *const ::std::os::raw::c_void,
        __c: ::std::os::raw::c_int,
        __n: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn memset(
        __s: *mut ::std::os::raw::c_void,
        __c: ::std::os::raw::c_int,
        __n: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn memcmp(
        __s1: *const ::std::os::raw::c_void,
        __s2: *const ::std::os::raw::c_void,
        __n: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn memchr(
        __s: *const ::std::os::raw::c_void,
        __c: ::std::os::raw::c_int,
        __n: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn strcpy(
        __dest: *mut ::std::os::raw::c_char,
        __src: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strncpy(
        __dest: *mut ::std::os::raw::c_char,
        __src: *const ::std::os::raw::c_char,
        __n: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strcat(
        __dest: *mut ::std::os::raw::c_char,
        __src: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strncat(
        __dest: *mut ::std::os::raw::c_char,
        __src: *const ::std::os::raw::c_char,
        __n: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strcmp(
        __s1: *const ::std::os::raw::c_char,
        __s2: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strncmp(
        __s1: *const ::std::os::raw::c_char,
        __s2: *const ::std::os::raw::c_char,
        __n: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strcoll(
        __s1: *const ::std::os::raw::c_char,
        __s2: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strxfrm(
        __dest: *mut ::std::os::raw::c_char,
        __src: *const ::std::os::raw::c_char,
        __n: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_ulong;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __locale_struct {
    pub __locales: [*mut __locale_data; 13usize],
    pub __ctype_b: *const ::std::os::raw::c_ushort,
    pub __ctype_tolower: *const ::std::os::raw::c_int,
    pub __ctype_toupper: *const ::std::os::raw::c_int,
    pub __names: [*const ::std::os::raw::c_char; 13usize],
}
#[test]
fn bindgen_test_layout___locale_struct() {
    const UNINIT: ::std::mem::MaybeUninit<__locale_struct> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__locale_struct>(),
        232usize,
        concat!("Size of: ", stringify!(__locale_struct))
    );
    assert_eq!(
        ::std::mem::align_of::<__locale_struct>(),
        8usize,
        concat!("Alignment of ", stringify!(__locale_struct))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__locales) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__locale_struct),
            "::",
            stringify!(__locales)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__ctype_b) as usize - ptr as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(__locale_struct),
            "::",
            stringify!(__ctype_b)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__ctype_tolower) as usize - ptr as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(__locale_struct),
            "::",
            stringify!(__ctype_tolower)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__ctype_toupper) as usize - ptr as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(__locale_struct),
            "::",
            stringify!(__ctype_toupper)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__names) as usize - ptr as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(__locale_struct),
            "::",
            stringify!(__names)
        )
    );
}
pub type __locale_t = *mut __locale_struct;
pub type locale_t = __locale_t;
extern "C" {
    pub fn strcoll_l(
        __s1: *const ::std::os::raw::c_char,
        __s2: *const ::std::os::raw::c_char,
        __l: locale_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strxfrm_l(
        __dest: *mut ::std::os::raw::c_char,
        __src: *const ::std::os::raw::c_char,
        __n: usize,
        __l: locale_t,
    ) -> usize;
}
extern "C" {
    pub fn strdup(__s: *const ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strndup(
        __string: *const ::std::os::raw::c_char,
        __n: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strchr(
        __s: *const ::std::os::raw::c_char,
        __c: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strrchr(
        __s: *const ::std::os::raw::c_char,
        __c: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strcspn(
        __s: *const ::std::os::raw::c_char,
        __reject: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn strspn(
        __s: *const ::std::os::raw::c_char,
        __accept: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn strpbrk(
        __s: *const ::std::os::raw::c_char,
        __accept: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strstr(
        __haystack: *const ::std::os::raw::c_char,
        __needle: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strtok(
        __s: *mut ::std::os::raw::c_char,
        __delim: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn __strtok_r(
        __s: *mut ::std::os::raw::c_char,
        __delim: *const ::std::os::raw::c_char,
        __save_ptr: *mut *mut ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strtok_r(
        __s: *mut ::std::os::raw::c_char,
        __delim: *const ::std::os::raw::c_char,
        __save_ptr: *mut *mut ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strlen(__s: *const ::std::os::raw::c_char) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn strnlen(__string: *const ::std::os::raw::c_char, __maxlen: usize) -> usize;
}
extern "C" {
    pub fn strerror(__errnum: ::std::os::raw::c_int) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    #[link_name = "\u{1}__xpg_strerror_r"]
    pub fn strerror_r(
        __errnum: ::std::os::raw::c_int,
        __buf: *mut ::std::os::raw::c_char,
        __buflen: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strerror_l(
        __errnum: ::std::os::raw::c_int,
        __l: locale_t,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn bcmp(
        __s1: *const ::std::os::raw::c_void,
        __s2: *const ::std::os::raw::c_void,
        __n: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn bcopy(
        __src: *const ::std::os::raw::c_void,
        __dest: *mut ::std::os::raw::c_void,
        __n: usize,
    );
}
extern "C" {
    pub fn bzero(__s: *mut ::std::os::raw::c_void, __n: ::std::os::raw::c_ulong);
}
extern "C" {
    pub fn index(
        __s: *const ::std::os::raw::c_char,
        __c: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn rindex(
        __s: *const ::std::os::raw::c_char,
        __c: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn ffs(__i: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ffsl(__l: ::std::os::raw::c_long) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ffsll(__ll: ::std::os::raw::c_longlong) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strcasecmp(
        __s1: *const ::std::os::raw::c_char,
        __s2: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strncasecmp(
        __s1: *const ::std::os::raw::c_char,
        __s2: *const ::std::os::raw::c_char,
        __n: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strcasecmp_l(
        __s1: *const ::std::os::raw::c_char,
        __s2: *const ::std::os::raw::c_char,
        __loc: locale_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strncasecmp_l(
        __s1: *const ::std::os::raw::c_char,
        __s2: *const ::std::os::raw::c_char,
        __n: usize,
        __loc: locale_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn explicit_bzero(__s: *mut ::std::os::raw::c_void, __n: usize);
}
extern "C" {
    pub fn strsep(
        __stringp: *mut *mut ::std::os::raw::c_char,
        __delim: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strsignal(__sig: ::std::os::raw::c_int) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn __stpcpy(
        __dest: *mut ::std::os::raw::c_char,
        __src: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn stpcpy(
        __dest: *mut ::std::os::raw::c_char,
        __src: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn __stpncpy(
        __dest: *mut ::std::os::raw::c_char,
        __src: *const ::std::os::raw::c_char,
        __n: usize,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn stpncpy(
        __dest: *mut ::std::os::raw::c_char,
        __src: *const ::std::os::raw::c_char,
        __n: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_char;
}
pub type __u_char = ::std::os::raw::c_uchar;
pub type __u_short = ::std::os::raw::c_ushort;
pub type __u_int = ::std::os::raw::c_uint;
pub type __u_long = ::std::os::raw::c_ulong;
pub type __int8_t = ::std::os::raw::c_schar;
pub type __uint8_t = ::std::os::raw::c_uchar;
pub type __int16_t = ::std::os::raw::c_short;
pub type __uint16_t = ::std::os::raw::c_ushort;
pub type __int32_t = ::std::os::raw::c_int;
pub type __uint32_t = ::std::os::raw::c_uint;
pub type __int64_t = ::std::os::raw::c_long;
pub type __uint64_t = ::std::os::raw::c_ulong;
pub type __int_least8_t = __int8_t;
pub type __uint_least8_t = __uint8_t;
pub type __int_least16_t = __int16_t;
pub type __uint_least16_t = __uint16_t;
pub type __int_least32_t = __int32_t;
pub type __uint_least32_t = __uint32_t;
pub type __int_least64_t = __int64_t;
pub type __uint_least64_t = __uint64_t;
pub type __quad_t = ::std::os::raw::c_long;
pub type __u_quad_t = ::std::os::raw::c_ulong;
pub type __intmax_t = ::std::os::raw::c_long;
pub type __uintmax_t = ::std::os::raw::c_ulong;
pub type __dev_t = ::std::os::raw::c_ulong;
pub type __uid_t = ::std::os::raw::c_uint;
pub type __gid_t = ::std::os::raw::c_uint;
pub type __ino_t = ::std::os::raw::c_ulong;
pub type __ino64_t = ::std::os::raw::c_ulong;
pub type __mode_t = ::std::os::raw::c_uint;
pub type __nlink_t = ::std::os::raw::c_ulong;
pub type __off_t = ::std::os::raw::c_long;
pub type __off64_t = ::std::os::raw::c_long;
pub type __pid_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __fsid_t {
    pub __val: [::std::os::raw::c_int; 2usize],
}
#[test]
fn bindgen_test_layout___fsid_t() {
    const UNINIT: ::std::mem::MaybeUninit<__fsid_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__fsid_t>(),
        8usize,
        concat!("Size of: ", stringify!(__fsid_t))
    );
    assert_eq!(
        ::std::mem::align_of::<__fsid_t>(),
        4usize,
        concat!("Alignment of ", stringify!(__fsid_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__val) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__fsid_t),
            "::",
            stringify!(__val)
        )
    );
}
pub type __clock_t = ::std::os::raw::c_long;
pub type __rlim_t = ::std::os::raw::c_ulong;
pub type __rlim64_t = ::std::os::raw::c_ulong;
pub type __id_t = ::std::os::raw::c_uint;
pub type __time_t = ::std::os::raw::c_long;
pub type __useconds_t = ::std::os::raw::c_uint;
pub type __suseconds_t = ::std::os::raw::c_long;
pub type __daddr_t = ::std::os::raw::c_int;
pub type __key_t = ::std::os::raw::c_int;
pub type __clockid_t = ::std::os::raw::c_int;
pub type __timer_t = *mut ::std::os::raw::c_void;
pub type __blksize_t = ::std::os::raw::c_long;
pub type __blkcnt_t = ::std::os::raw::c_long;
pub type __blkcnt64_t = ::std::os::raw::c_long;
pub type __fsblkcnt_t = ::std::os::raw::c_ulong;
pub type __fsblkcnt64_t = ::std::os::raw::c_ulong;
pub type __fsfilcnt_t = ::std::os::raw::c_ulong;
pub type __fsfilcnt64_t = ::std::os::raw::c_ulong;
pub type __fsword_t = ::std::os::raw::c_long;
pub type __ssize_t = ::std::os::raw::c_long;
pub type __syscall_slong_t = ::std::os::raw::c_long;
pub type __syscall_ulong_t = ::std::os::raw::c_ulong;
pub type __loff_t = __off64_t;
pub type __caddr_t = *mut ::std::os::raw::c_char;
pub type __intptr_t = ::std::os::raw::c_long;
pub type __socklen_t = ::std::os::raw::c_uint;
pub type __sig_atomic_t = ::std::os::raw::c_int;
pub type int_least8_t = __int_least8_t;
pub type int_least16_t = __int_least16_t;
pub type int_least32_t = __int_least32_t;
pub type int_least64_t = __int_least64_t;
pub type uint_least8_t = __uint_least8_t;
pub type uint_least16_t = __uint_least16_t;
pub type uint_least32_t = __uint_least32_t;
pub type uint_least64_t = __uint_least64_t;
pub type int_fast8_t = ::std::os::raw::c_schar;
pub type int_fast16_t = ::std::os::raw::c_long;
pub type int_fast32_t = ::std::os::raw::c_long;
pub type int_fast64_t = ::std::os::raw::c_long;
pub type uint_fast8_t = ::std::os::raw::c_uchar;
pub type uint_fast16_t = ::std::os::raw::c_ulong;
pub type uint_fast32_t = ::std::os::raw::c_ulong;
pub type uint_fast64_t = ::std::os::raw::c_ulong;
pub type intmax_t = __intmax_t;
pub type uintmax_t = __uintmax_t;
pub type wchar_t = ::std::os::raw::c_int;
#[repr(C)]
#[repr(align(16))]
#[derive(Debug, Copy, Clone)]
pub struct max_align_t {
    pub __clang_max_align_nonce1: ::std::os::raw::c_longlong,
    pub __bindgen_padding_0: u64,
    pub __clang_max_align_nonce2: u128,
}
#[test]
fn bindgen_test_layout_max_align_t() {
    const UNINIT: ::std::mem::MaybeUninit<max_align_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<max_align_t>(),
        32usize,
        concat!("Size of: ", stringify!(max_align_t))
    );
    assert_eq!(
        ::std::mem::align_of::<max_align_t>(),
        16usize,
        concat!("Alignment of ", stringify!(max_align_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__clang_max_align_nonce1) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(max_align_t),
            "::",
            stringify!(__clang_max_align_nonce1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__clang_max_align_nonce2) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(max_align_t),
            "::",
            stringify!(__clang_max_align_nonce2)
        )
    );
}
extern "C" {
    #[doc = " @brief Function returning DOCA's (runtime) version string.\n\n @return\n version string, using the format major.minor.patch.\n\n @note Represents the runtime version a project is linked against."]
    pub fn doca_version_runtime() -> *const ::std::os::raw::c_char;
}
pub const doca_error_DOCA_SUCCESS: doca_error = 0;
pub const doca_error_DOCA_ERROR_UNKNOWN: doca_error = 1;
#[doc = "< Operation not permitted"]
pub const doca_error_DOCA_ERROR_NOT_PERMITTED: doca_error = 2;
#[doc = "< Resource already in use"]
pub const doca_error_DOCA_ERROR_IN_USE: doca_error = 3;
#[doc = "< Operation not supported"]
pub const doca_error_DOCA_ERROR_NOT_SUPPORTED: doca_error = 4;
#[doc = "< Resource temporarily unavailable, try again"]
pub const doca_error_DOCA_ERROR_AGAIN: doca_error = 5;
#[doc = "< Invalid input"]
pub const doca_error_DOCA_ERROR_INVALID_VALUE: doca_error = 6;
#[doc = "< Memory allocation failure"]
pub const doca_error_DOCA_ERROR_NO_MEMORY: doca_error = 7;
#[doc = "< Resource initialization failure"]
pub const doca_error_DOCA_ERROR_INITIALIZATION: doca_error = 8;
#[doc = "< Timer expired waiting for resource"]
pub const doca_error_DOCA_ERROR_TIME_OUT: doca_error = 9;
#[doc = "< Shut down in process or completed"]
pub const doca_error_DOCA_ERROR_SHUTDOWN: doca_error = 10;
#[doc = "< Connection reset by peer"]
pub const doca_error_DOCA_ERROR_CONNECTION_RESET: doca_error = 11;
#[doc = "< Connection aborted"]
pub const doca_error_DOCA_ERROR_CONNECTION_ABORTED: doca_error = 12;
#[doc = "< Connection in progress"]
pub const doca_error_DOCA_ERROR_CONNECTION_INPROGRESS: doca_error = 13;
#[doc = "< Not Connected"]
pub const doca_error_DOCA_ERROR_NOT_CONNECTED: doca_error = 14;
#[doc = "< Unable to acquire required lock"]
pub const doca_error_DOCA_ERROR_NO_LOCK: doca_error = 15;
#[doc = "< Resource Not Found"]
pub const doca_error_DOCA_ERROR_NOT_FOUND: doca_error = 16;
#[doc = "< Input/Output Operation Failed"]
pub const doca_error_DOCA_ERROR_IO_FAILED: doca_error = 17;
#[doc = "< Bad State"]
pub const doca_error_DOCA_ERROR_BAD_STATE: doca_error = 18;
#[doc = "< Unsupported version"]
pub const doca_error_DOCA_ERROR_UNSUPPORTED_VERSION: doca_error = 19;
#[doc = "< Operating system call failure"]
pub const doca_error_DOCA_ERROR_OPERATING_SYSTEM: doca_error = 20;
#[doc = "< DOCA Driver call failure"]
pub const doca_error_DOCA_ERROR_DRIVER: doca_error = 21;
#[doc = "< An unexpected scenario was detected"]
pub const doca_error_DOCA_ERROR_UNEXPECTED: doca_error = 22;
pub type doca_error = ::std::os::raw::c_uint;
pub use self::doca_error as doca_error_t;
extern "C" {
    #[doc = " \\brief Returns the string representation of an error code name.\n\n Returns a string containing the name of an error code in the enum.\n If the error code is not recognized, \"unrecognized error code\" is returned.\n\n @param[in] error - Error code to convert to string.\n\n @return char* pointer to a NULL-terminated string."]
    pub fn doca_get_error_name(error: doca_error_t) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " \\brief Returns the description string of an error code.\n\n  This function returns the description string of an error code.\n  If the error code is not recognized, \"unrecognized error code\" is returned.\n\n @param[in] error - Error code to convert to description string.\n\n @return char* pointer to a NULL-terminated string."]
    pub fn doca_get_error_string(error: doca_error_t) -> *const ::std::os::raw::c_char;
}
pub type doca_event_handle_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Copy, Clone)]
pub union doca_data {
    pub ptr: *mut ::std::os::raw::c_void,
    pub u64_: u64,
}
#[test]
fn bindgen_test_layout_doca_data() {
    const UNINIT: ::std::mem::MaybeUninit<doca_data> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<doca_data>(),
        8usize,
        concat!("Size of: ", stringify!(doca_data))
    );
    assert_eq!(
        ::std::mem::align_of::<doca_data>(),
        8usize,
        concat!("Alignment of ", stringify!(doca_data))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ptr) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(doca_data),
            "::",
            stringify!(ptr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).u64_) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(doca_data),
            "::",
            stringify!(u64_)
        )
    );
}
pub const doca_access_flags_DOCA_ACCESS_LOCAL_READ: doca_access_flags = 0;
pub const doca_access_flags_DOCA_ACCESS_LOCAL_WRITE: doca_access_flags = 1;
pub const doca_access_flags_DOCA_ACCESS_REMOTE_WRITE: doca_access_flags = 2;
pub const doca_access_flags_DOCA_ACCESS_REMOTE_READ: doca_access_flags = 4;
pub const doca_access_flags_DOCA_ACCESS_REMOTE_ATOMIC: doca_access_flags = 8;
#[doc = " @brief Specifies the permission level for DOCA buffer\n"]
pub type doca_access_flags = ::std::os::raw::c_uint;
pub const doca_pci_func_type_DOCA_PCI_FUNC_PF: doca_pci_func_type = 0;
pub const doca_pci_func_type_DOCA_PCI_FUNC_VF: doca_pci_func_type = 1;
pub const doca_pci_func_type_DOCA_PCI_FUNC_SF: doca_pci_func_type = 2;
#[doc = " @brief Specifies the PCI function type for DOCA representor device\n"]
pub type doca_pci_func_type = ::std::os::raw::c_uint;
#[doc = " @brief The PCI address of a device - same as the address in lspci\n"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct doca_pci_bdf {
    pub __bindgen_anon_1: doca_pci_bdf__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union doca_pci_bdf__bindgen_ty_1 {
    pub raw: u16,
    pub __bindgen_anon_1: doca_pci_bdf__bindgen_ty_1__bindgen_ty_1,
}
#[repr(C)]
#[repr(align(2))]
#[derive(Debug, Copy, Clone)]
pub struct doca_pci_bdf__bindgen_ty_1__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize]>,
}
#[test]
fn bindgen_test_layout_doca_pci_bdf__bindgen_ty_1__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<doca_pci_bdf__bindgen_ty_1__bindgen_ty_1>(),
        2usize,
        concat!(
            "Size of: ",
            stringify!(doca_pci_bdf__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<doca_pci_bdf__bindgen_ty_1__bindgen_ty_1>(),
        2usize,
        concat!(
            "Alignment of ",
            stringify!(doca_pci_bdf__bindgen_ty_1__bindgen_ty_1)
        )
    );
}
impl doca_pci_bdf__bindgen_ty_1__bindgen_ty_1 {
    #[inline]
    pub fn bus(&self) -> u16 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 8u8) as u16) }
    }
    #[inline]
    pub fn set_bus(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn device(&self) -> u16 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(8usize, 5u8) as u16) }
    }
    #[inline]
    pub fn set_device(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(8usize, 5u8, val as u64)
        }
    }
    #[inline]
    pub fn function(&self) -> u16 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(13usize, 3u8) as u16) }
    }
    #[inline]
    pub fn set_function(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(13usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        bus: u16,
        device: u16,
        function: u16,
    ) -> __BindgenBitfieldUnit<[u8; 2usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 8u8, {
            let bus: u16 = unsafe { ::std::mem::transmute(bus) };
            bus as u64
        });
        __bindgen_bitfield_unit.set(8usize, 5u8, {
            let device: u16 = unsafe { ::std::mem::transmute(device) };
            device as u64
        });
        __bindgen_bitfield_unit.set(13usize, 3u8, {
            let function: u16 = unsafe { ::std::mem::transmute(function) };
            function as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_doca_pci_bdf__bindgen_ty_1() {
    const UNINIT: ::std::mem::MaybeUninit<doca_pci_bdf__bindgen_ty_1> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<doca_pci_bdf__bindgen_ty_1>(),
        2usize,
        concat!("Size of: ", stringify!(doca_pci_bdf__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<doca_pci_bdf__bindgen_ty_1>(),
        2usize,
        concat!("Alignment of ", stringify!(doca_pci_bdf__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).raw) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(doca_pci_bdf__bindgen_ty_1),
            "::",
            stringify!(raw)
        )
    );
}
#[test]
fn bindgen_test_layout_doca_pci_bdf() {
    assert_eq!(
        ::std::mem::size_of::<doca_pci_bdf>(),
        2usize,
        concat!("Size of: ", stringify!(doca_pci_bdf))
    );
    assert_eq!(
        ::std::mem::align_of::<doca_pci_bdf>(),
        2usize,
        concat!("Alignment of ", stringify!(doca_pci_bdf))
    );
}
#[doc = " @brief Opaque structure representing a local DOCA Device Info instance.\n This structure is used to query information about the local device."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct doca_devinfo {
    _unused: [u8; 0],
}
#[doc = " @brief Opaque structure representing a representor DOCA Device Info instance.\n This structure is used to query information about the representor device."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct doca_devinfo_rep {
    _unused: [u8; 0],
}
#[doc = " @brief Opaque structure representing a local DOCA Device instance.\n This structure is used by libraries for accessing the underlying local device."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct doca_dev {
    _unused: [u8; 0],
}
#[doc = " @brief Opaque structure representing a representor DOCA Device instance.\n This structure is used by libraries for accessing the underlying representor device."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct doca_dev_rep {
    _unused: [u8; 0],
}
pub const doca_dev_rep_filter_DOCA_DEV_REP_FILTER_ALL: doca_dev_rep_filter = 0;
pub const doca_dev_rep_filter_DOCA_DEV_REP_FILTER_NET: doca_dev_rep_filter = 2;
pub const doca_dev_rep_filter_DOCA_DEV_REP_FILTER_VIRTIO_FS: doca_dev_rep_filter = 4;
pub const doca_dev_rep_filter_DOCA_DEV_REP_FILTER_VIRTIO_NET: doca_dev_rep_filter = 8;
pub const doca_dev_rep_filter_DOCA_DEV_REP_FILTER_VIRTIO_BLK: doca_dev_rep_filter = 16;
pub const doca_dev_rep_filter_DOCA_DEV_REP_FILTER_NVME: doca_dev_rep_filter = 32;
#[doc = " Representor device filter by flavor\n\n Multiple options possible but some are mutually exclusive.\n"]
pub type doca_dev_rep_filter = ::std::os::raw::c_uint;
extern "C" {
    #[doc = " @brief Creates list of all available local devices.\n\n Lists information about available devices, to start using the device you first have to call doca_dev_open(),\n while passing an element of this list. List elements become invalid once it has been destroyed.\n\n @param [out] dev_list\n Pointer to array of pointers. Output can then be accessed as follows (*dev_list)[idx].\n @param [out] nb_devs\n Number of available local devices.\n\n @return\n DOCA_SUCCESS - in case of success.\n Error code - in case of failure:\n - DOCA_ERROR_INVALID_VALUE - received invalid input.\n - DOCA_ERROR_NO_MEMORY - failed to allocate enough space.\n - DOCA_ERROR_NOT_FOUND - failed to get RDMA devices list\n @note Returned list must be destroyed using doca_devinfo_list_destroy()"]
    pub fn doca_devinfo_list_create(
        dev_list: *mut *mut *mut doca_devinfo,
        nb_devs: *mut u32,
    ) -> doca_error_t;
}
extern "C" {
    #[doc = " @brief Destroy list of local device info structures.\n\n Destroys the list of device information, once the list has been destroyed, all elements become invalid.\n\n @param [in] dev_list\n List to be destroyed.\n\n @return\n DOCA_SUCCESS - in case of success.\n Error code - in case of failure:\n - DOCA_ERROR_INVALID_VALUE - received invalid input.\n - DOCA_ERROR_IN_USE - at least one device in the list is in a corrupted state."]
    pub fn doca_devinfo_list_destroy(dev_list: *mut *mut doca_devinfo) -> doca_error_t;
}
extern "C" {
    #[doc = " @brief Create list of available representor devices accessible by dev.\n\n Returns all representors managed by the provided device.\n The provided device must be a local device.\n The representor may represent a network function attached to the host,\n or it can represent an emulated function attached to the host.\n\n @param [in] dev\n Local device with access to representors.\n @param [in] filter\n Bitmap filter of representor types. See enum doca_dev_rep_filter for more details.\n @param [out] dev_list_rep\n Pointer to array of pointers. Output can then be accessed as follows (*dev_list_rep)[idx].\n @param [out] nb_devs_rep\n Number of available representor devices.\n\n @return\n DOCA_SUCCESS - in case of success.\n Error code - in case of failure:\n - DOCA_ERROR_INVALID_VALUE - received invalid input.\n - DOCA_ERROR_NO_MEMORY - failed to allocate memory for list.\n - DOCA_ERROR_NOT_SUPPORTED - local device does not expose representor devices.\n @note Returned list must be destroyed using doca_devinfo_rep_list_destroy()"]
    pub fn doca_devinfo_rep_list_create(
        dev: *mut doca_dev,
        filter: ::std::os::raw::c_int,
        dev_list_rep: *mut *mut *mut doca_devinfo_rep,
        nb_devs_rep: *mut u32,
    ) -> doca_error_t;
}
extern "C" {
    #[doc = " @brief Destroy list of representor device info structures.\n\n Destroy list of representor device information, once the list has been destroyed,\n all elements of the list are considered invalid.\n\n @param [in] dev_list_rep\n List to be destroyed.\n\n @return\n DOCA_SUCCESS - in case of success.\n Error code - in case of failure:\n - DOCA_ERROR_INVALID_VALUE - received invalid input.\n - DOCA_ERROR_IN_USE - the doca_dev that created the list is in a corrupted state."]
    pub fn doca_devinfo_rep_list_destroy(dev_list_rep: *mut *mut doca_devinfo_rep) -> doca_error_t;
}
extern "C" {
    #[doc = " @brief Initialize local device for use.\n\n @param [in] devinfo\n The devinfo structure of the requested device.\n @param [out] dev\n Initialized local doca device instance on success. Valid on success only.\n\n @return\n DOCA_SUCCESS - in case of success.\n Error code - in case of failure:\n - DOCA_ERROR_INVALID_VALUE - received invalid input.\n - DOCA_ERROR_NO_MEMORY - failed to allocate protection domain for device.\n - DOCA_ERROR_NOT_CONNECTED - failed to open device.\n @note In case the same device was previously opened, then the same doca_dev instance is returned."]
    pub fn doca_dev_open(devinfo: *mut doca_devinfo, dev: *mut *mut doca_dev) -> doca_error_t;
}
extern "C" {
    #[doc = " @brief Destroy allocated local device instance.\n\n @param [in] dev\n The local doca device instance.\n\n @return\n DOCA_SUCCESS - in case of success.\n - DOCA_ERROR_IN_USE - failed to deallocate device resources."]
    pub fn doca_dev_close(dev: *mut doca_dev) -> doca_error_t;
}
extern "C" {
    #[doc = " @brief Initialize representor device for use.\n\n @param [in] devinfo\n The devinfo structure of the requested device.\n @param [out] dev_rep\n Initialized representor doca device instance on success. Valid on success only.\n\n @return\n DOCA_SUCCESS - in case of success.\n Error code - in case of failure:\n - DOCA_ERROR_INVALID_VALUE - received invalid input.\n - DOCA_ERROR_NO_MEMORY - failed to allocate memory for device."]
    pub fn doca_dev_rep_open(
        devinfo: *mut doca_devinfo_rep,
        dev_rep: *mut *mut doca_dev_rep,
    ) -> doca_error_t;
}
extern "C" {
    #[doc = " @brief Destroy allocated representor device instance.\n\n @param [in] dev\n The representor doca device instance.\n\n @return\n DOCA_SUCCESS - in case of success.\n Error code - in case of failure:\n - DOCA_ERROR_INVALID_VALUE - received invalid input.\n - DOCA_ERROR_IN_USE - failed to deallocate device resources."]
    pub fn doca_dev_rep_close(dev: *mut doca_dev_rep) -> doca_error_t;
}
extern "C" {
    #[doc = " @brief Get local device info from device.\n This should be useful when wanting to query information about device after opening it,\n and destroying the devinfo list.\n\n @param [in] dev\n The doca device instance.\n\n @return\n The matching doca_devinfo instance in case of success, NULL in case dev is invalid."]
    pub fn doca_dev_as_devinfo(dev: *const doca_dev) -> *mut doca_devinfo;
}
extern "C" {
    #[doc = " @brief Get representor device info from device.\n This should be useful when wanting to query information about device after opening it,\n and destroying the devinfo list.\n\n @param [in] dev_rep\n The representor doca device instance.\n\n @return\n The matching doca_devinfo_rep instance in case of success, NULL in case dev_rep is invalid."]
    pub fn doca_dev_rep_as_devinfo(dev_rep: *mut doca_dev_rep) -> *mut doca_devinfo_rep;
}
extern "C" {
    #[doc = " @brief Get the PCI address of a DOCA devinfo.\n\n @details The BDF of the device - same as the address in lspci.\n The PCI address type: struct doca_pci_bdf.\n\n @param [in] devinfo\n The device to query.\n @param [out] pci_addr\n The PCI address of devinfo.\n\n @return\n DOCA_SUCCESS - in case of success.\n Error code - in case of failure:\n - DOCA_ERROR_INVALID_VALUE - received invalid input.\n - DOCA_ERROR_NOT_CONNECTED - provided devinfo does not support this property.\n - DOCA_ERROR_OPERATING_SYSTEM - failed to acquire the PCI address from the OS"]
    pub fn doca_devinfo_get_pci_addr(
        devinfo: *const doca_devinfo,
        pci_addr: *mut doca_pci_bdf,
    ) -> doca_error_t;
}
extern "C" {
    #[doc = " @brief Get the IPv4 address of a DOCA devinfo.\n\n @details The IPv4 address type: uint8_t[DOCA_DEVINFO_IPV4_ADDR_SIZE].\n\n @param [in] devinfo\n The device to query.\n @param [out] ipv4_addr\n The IPv4 address of devinfo.\n @param [in] size\n The size of the input ipv4_addr buffer, must be at least DOCA_DEVINFO_IPV4_ADDR_SIZE\n\n @return\n DOCA_SUCCESS - in case of success.\n Error code - in case of failure:\n - DOCA_ERROR_INVALID_VALUE - received invalid input.\n - DOCA_ERROR_OPERATING_SYSTEM - failed to acquire the IPv4 address from the OS"]
    pub fn doca_devinfo_get_ipv4_addr(
        devinfo: *const doca_devinfo,
        ipv4_addr: *mut u8,
        size: u32,
    ) -> doca_error_t;
}
extern "C" {
    #[doc = " @brief Get the IPv6 address of a DOCA devinfo.\n\n @details The IPv6 address type: uint8_t[DOCA_DEVINFO_IPV6_ADDR_SIZE].\n\n @param [in] devinfo\n The device to query.\n @param [out] ipv6_addr\n The IPv6 address of devinfo.\n @param [in] size\n The size of the input ipv6_addr buffer, must be at least DOCA_DEVINFO_IPV6_ADDR_SIZE\n\n @return\n DOCA_SUCCESS - in case of success.\n Error code - in case of failure:\n - DOCA_ERROR_INVALID_VALUE - received invalid input.\n - DOCA_ERROR_OPERATING_SYSTEM - failed to acquire the IPv6 address from the OS"]
    pub fn doca_devinfo_get_ipv6_addr(
        devinfo: *const doca_devinfo,
        ipv6_addr: *mut u8,
        size: u32,
    ) -> doca_error_t;
}
extern "C" {
    #[doc = " @brief Get the name of the ethernet interface of a DOCA devinfo.\n\n @details The name of the ethernet interface is the same as it's name in ifconfig.\n The name of the ethernet interface type: char[DOCA_DEVINFO_IFACE_NAME_SIZE].\n\n @param [in] devinfo\n The device to query.\n @param [out] iface_name\n The name of the ethernet interface of devinfo.\n @param [in] size\n The size of the input iface_name buffer, must be at least DOCA_DEVINFO_IFACE_NAME_SIZE\n which includes the null terminating byte.\n\n @return\n DOCA_SUCCESS - in case of success.\n Error code - in case of failure:\n - DOCA_ERROR_INVALID_VALUE - received invalid input.\n - DOCA_ERROR_OPERATING_SYSTEM - failed to acquire the interface name from the OS"]
    pub fn doca_devinfo_get_iface_name(
        devinfo: *const doca_devinfo,
        iface_name: *mut ::std::os::raw::c_char,
        size: u32,
    ) -> doca_error_t;
}
extern "C" {
    #[doc = " @brief Get the name of the IB device represented by a DOCA devinfo.\n\n @details The name of the IB device type: char[DOCA_DEVINFO_IBDEV_NAME_SIZE].\n\n @param [in] devinfo\n The device to query.\n @param [out] ibdev_name\n The name of the IB device represented by devinfo.\n @param [in] size\n The size of the input ibdev_name buffer, must be at least DOCA_DEVINFO_IBDEV_NAME_SIZE\n which includes the null terminating byte.\n\n @return\n DOCA_SUCCESS - in case of success.\n Error code - in case of failure:\n - DOCA_ERROR_INVALID_VALUE - received invalid input.\n - DOCA_ERROR_NO_MEMORY - no memory (exception thrown)."]
    pub fn doca_devinfo_get_ibdev_name(
        devinfo: *const doca_devinfo,
        ibdev_name: *mut ::std::os::raw::c_char,
        size: u32,
    ) -> doca_error_t;
}
extern "C" {
    #[doc = " @brief Get the hotplug manager capability of a DOCA devinfo.\n\n @details The hotplug manager property type: uint8_t*.\n\n @param [in] devinfo\n The device to query.\n @param [out] is_hotplug_manager\n 1 if the hotplug manager capability is supported, 0 otherwise.\n\n @return\n DOCA_SUCCESS - in case of success.\n Error code - in case of failure:\n - DOCA_ERROR_INVALID_VALUE - received invalid input.\n - DOCA_ERROR_DRIVER - failed to query capability support."]
    pub fn doca_devinfo_get_is_hotplug_manager_supported(
        devinfo: *const doca_devinfo,
        is_hotplug_manager: *mut u8,
    ) -> doca_error_t;
}
extern "C" {
    #[doc = " @brief Get the mmap export capability of the device.\n\n @details Get uint8_t value defining if the device can be used to export an mmap.\n See doca_mmap_export() in doca_mmap.h\n true  - device can be used with the mmap export API.\n false - export API is guaranteed to faile with DOCA_ERROR_NOT_SUPPORTED.\n\n @param [in] devinfo\n The device to query.\n @param [out] export\n 1 if the mmap export capability is supported, 0 otherwise.\n @return\n DOCA_SUCCESS - in case of success.\n Error code - in case of failure:\n - DOCA_ERROR_INVALID_VALUE - received invalid input.\n - DOCA_ERROR_DRIVER - failed to query capability support."]
    pub fn doca_devinfo_get_is_mmap_export_supported(
        devinfo: *const doca_devinfo,
        mmap_export: *mut u8,
    ) -> doca_error_t;
}
extern "C" {
    #[doc = " @brief Get the mmap create from export capability of the device.\n\n @details Get uint8_t value defining if the device can be used to create an mmap from an exported mmap.\n See doca_mmap_create_from_export() in doca_mmap.h\n true  - device can be used with the mmap create from export API.\n false - create from export API is guaranteed to fail with DOCA_ERROR_NOT_SUPPORTED.\n\n @param [in] devinfo\n The device to query.\n @param [out] from_export\n 1 if the mmap from export capability is supported, 0 otherwise.\n\n @return\n DOCA_SUCCESS - in case of success.\n Error code - in case of failure:\n - DOCA_ERROR_INVALID_VALUE - received invalid input.\n - DOCA_ERROR_DRIVER - failed to query capability support."]
    pub fn doca_devinfo_get_is_mmap_from_export_supported(
        devinfo: *const doca_devinfo,
        from_export: *mut u8,
    ) -> doca_error_t;
}
extern "C" {
    #[doc = " @brief Get the representor devices discovery capability of the device.\n\n @details Get uint8_t value defining if the device can be used to create list of representor devices.\n In case true is returned, then this device supports at least one representor type.\n See doca_devinfo_rep_list_create().\n true  - device can be used with the remote list create API with filter DOCA_DEV_REP_FILTER_ALL.\n false - providing DOCA_DEV_REP_FILTER_ALL is guaranteed to fail with DOCA_ERROR_NOT_SUPPORTED.\n\n @param [in] devinfo\n The device to query.\n @param [out] all_supported\n 1 if the rep list all capability is supported, 0 otherwise.\n\n @return\n DOCA_SUCCESS - in case of success.\n Error code - in case of failure:\n - DOCA_ERROR_INVALID_VALUE - received invalid input.\n - DOCA_ERROR_DRIVER - failed to query capability support."]
    pub fn doca_devinfo_rep_get_is_list_all_supported(
        devinfo: *const doca_devinfo,
        all_supported: *mut u8,
    ) -> doca_error_t;
}
extern "C" {
    #[doc = " @brief Get the remote net discovery capability of the device.\n\n @details Get uint8_t value defining if the device can be used to create list of net remote devices.\n See doca_devinfo_remote_list_create().\n true  - device can be used with the remote list create API with filter DOCA_DEV_REMOTE_FILTER_NET.\n false - providing DOCA_DEV_REMOTE_FILTER_NET is guaranteed to fail with DOCA_ERROR_NOT_SUPPORTED.\n\n @param [in] devinfo\n The device to query.\n @param [out] net_supported\n 1 if the rep list net capability is supported, 0 otherwise.\n\n @return\n DOCA_SUCCESS - in case of success.\n Error code - in case of failure:\n - DOCA_ERROR_INVALID_VALUE - received invalid input.\n - DOCA_ERROR_DRIVER - failed to query capability support."]
    pub fn doca_devinfo_rep_get_is_list_net_supported(
        devinfo: *const doca_devinfo,
        net_supported: *mut u8,
    ) -> doca_error_t;
}
extern "C" {
    #[doc = " @brief Get the remote virtio fs discovery capability of the device.\n\n @details Get uint8_t value defining if the device can be used to create list of virtio fs remote devices.\n See doca_devinfo_remote_list_create().\n true  - device can be used with the remote list create API with filter DOCA_DEV_REMOTE_FILTER_VIRTIO_FS.\n false - providing DOCA_DEV_REMOTE_FILTER_VIRTIO_FS is guaranteed to fail with DOCA_ERROR_NOT_SUPPORTED.\n\n @param [in] devinfo\n The device to query.\n @param [out] virtio_fs_supported\n 1 if the list virtio fs capability is supported, 0 otherwise.\n\n @return\n DOCA_SUCCESS - in case of success.\n Error code - in case of failure:\n - DOCA_ERROR_INVALID_VALUE - received invalid input.\n - DOCA_ERROR_DRIVER - failed to query capability support."]
    pub fn doca_devinfo_rep_get_is_list_virtio_fs_supported(
        devinfo: *const doca_devinfo,
        virtio_fs_supported: *mut u8,
    ) -> doca_error_t;
}
extern "C" {
    #[doc = " @brief Get the remote virtio net discovery capability of the device.\n\n @details Get uint8_t value defining if the device can be used to create list of virtio net remote devices.\n See doca_devinfo_remote_list_create().\n true  - device can be used with the remote list create API with filter DOCA_DEV_REMOTE_FILTER_VIRTIO_NET.\n false - providing DOCA_DEV_REMOTE_FILTER_VIRTIO_NET is guaranteed to fail with DOCA_ERROR_NOT_SUPPORTED.\n\n @param [in] devinfo\n The device to query.\n @param [out] virtio_net_supported\n 1 if the list virtio net capability is supported, 0 otherwise.\n\n @return\n DOCA_SUCCESS - in case of success.\n Error code - in case of failure:\n - DOCA_ERROR_INVALID_VALUE - received invalid input.\n - DOCA_ERROR_DRIVER - failed to query capability support."]
    pub fn doca_devinfo_rep_get_is_list_virtio_net_supported(
        devinfo: *const doca_devinfo,
        virtio_net_supported: *mut u8,
    ) -> doca_error_t;
}
extern "C" {
    #[doc = " @brief Get the remote virtio blk discovery capability of the device.\n\n @details Get uint8_t value defining if the device can be used to create list of virtio blk remote devices.\n See doca_devinfo_remote_list_create().\n true  - device can be used with the remote list create API with filter DOCA_DEV_REMOTE_FILTER_VIRTIO_BLK.\n false - providing DOCA_DEV_REMOTE_FILTER_VIRTIO_BLK is guaranteed to fail with DOCA_ERROR_NOT_SUPPORTED.\n\n @param [in] devinfo\n The device to query.\n @param [out] virtio_blk_supported\n 1 if the list virtio blk capability is supported, 0 otherwise.\n\n @return\n DOCA_SUCCESS - in case of success.\n Error code - in case of failure:\n - DOCA_ERROR_INVALID_VALUE - received invalid input.\n - DOCA_ERROR_DRIVER - failed to query capability support."]
    pub fn doca_devinfo_rep_get_is_list_virtio_blk_supported(
        devinfo: *const doca_devinfo,
        virtio_blk_supported: *mut u8,
    ) -> doca_error_t;
}
extern "C" {
    #[doc = " @brief Get the remote nvme discovery capability of the device.\n\n @details Get uint8_t value defining if the device can be used to create list of nvme remote devices.\n See doca_devinfo_remote_list_create().\n true  - device can be used with the remote list create API with filter DOCA_DEV_REMOTE_FILTER_NVME.\n false - providing DOCA_DEV_REMOTE_FILTER_NVME is guaranteed to fail with DOCA_ERROR_NOT_SUPPORTED.\n\n @param [in] devinfo\n The device to query.\n @param [out] nvme_supported\n 1 if the list nvme capability is supported, 0 otherwise.\n\n @return\n DOCA_SUCCESS - in case of success.\n Error code - in case of failure:\n - DOCA_ERROR_INVALID_VALUE - received invalid input.\n - DOCA_ERROR_DRIVER - failed to query capability support."]
    pub fn doca_devinfo_rep_get_is_list_nvme_supported(
        devinfo: *const doca_devinfo,
        nvme_supported: *mut u8,
    ) -> doca_error_t;
}
extern "C" {
    #[doc = " @brief Get the Vendor Unique ID of a representor DOCA devinfo.\n\n @details The Vendor Unique ID is used as stable ID of a VF/PF.\n The Vendor Unique ID type: char[DOCA_DEVINFO_VUID_SIZE].\n\n @param [in] devinfo_rep\n The representor device to query.\n @param [out] rep_vuid\n The Vendor Unique ID of devinfo_rep.\n @param [in] size\n The size of the vuid buffer, including the terminating null byte ('\\0').\n\n @return\n DOCA_SUCCESS - in case of success.\n Error code - in case of failure:\n - DOCA_ERROR_INVALID_VALUE - received invalid input."]
    pub fn doca_devinfo_rep_get_vuid(
        devinfo_rep: *const doca_devinfo_rep,
        rep_vuid: *mut ::std::os::raw::c_char,
        size: u32,
    ) -> doca_error_t;
}
extern "C" {
    #[doc = " @brief Get the PCI address of a DOCA devinfo_rep.\n\n @details The PCI address type: struct doca_pci_bdf.\n\n @param [in] devinfo_rep\n The representor of device to query.\n @param [out] pci_addr\n The PCI address of the devinfo_rep.\n\n @return\n DOCA_SUCCESS - in case of success.\n Error code - in case of failure:\n - DOCA_ERROR_INVALID_VALUE - received invalid input."]
    pub fn doca_devinfo_rep_get_pci_addr(
        devinfo_rep: *const doca_devinfo_rep,
        pci_addr: *mut doca_pci_bdf,
    ) -> doca_error_t;
}
extern "C" {
    #[doc = " @brief Get the PCI function type of a DOCA devinfo_rep.\n\n @details The pci function type: enum doca_pci_func_type.\n\n @param [in] devinfo_rep\n The representor of device to query.\n @param [out] pci_func_type\n The PCI function type of the devinfo_rep.\n\n @return\n DOCA_SUCCESS - in case of success.\n Error code - in case of failure:\n - DOCA_ERROR_INVALID_VALUE - received invalid input."]
    pub fn doca_devinfo_rep_get_pci_func_type(
        devinfo_rep: *const doca_devinfo_rep,
        pci_func_type: *mut doca_pci_func_type,
    ) -> doca_error_t;
}
pub type jobs_check =
    ::std::option::Option<unsafe extern "C" fn(arg1: *mut doca_devinfo) -> doca_error_t>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct program_core_objects {
    pub dev: *mut doca_dev,
    pub mmap: *mut doca_mmap,
    pub buf_inv: *mut doca_buf_inventory,
    pub ctx: *mut doca_ctx,
    pub workq: *mut doca_workq,
}
#[test]
fn bindgen_test_layout_program_core_objects() {
    const UNINIT: ::std::mem::MaybeUninit<program_core_objects> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<program_core_objects>(),
        40usize,
        concat!("Size of: ", stringify!(program_core_objects))
    );
    assert_eq!(
        ::std::mem::align_of::<program_core_objects>(),
        8usize,
        concat!("Alignment of ", stringify!(program_core_objects))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).dev) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(program_core_objects),
            "::",
            stringify!(dev)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).mmap) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(program_core_objects),
            "::",
            stringify!(mmap)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).buf_inv) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(program_core_objects),
            "::",
            stringify!(buf_inv)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ctx) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(program_core_objects),
            "::",
            stringify!(ctx)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).workq) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(program_core_objects),
            "::",
            stringify!(workq)
        )
    );
}
extern "C" {
    pub fn open_doca_device_with_pci(
        value: *const doca_pci_bdf,
        func: jobs_check,
        retval: *mut *mut doca_dev,
    ) -> doca_error_t;
}
extern "C" {
    pub fn open_doca_device_with_ibdev_name(
        value: *const u8,
        val_size: usize,
        func: jobs_check,
        retval: *mut *mut doca_dev,
    ) -> doca_error_t;
}
extern "C" {
    pub fn open_doca_device_with_capabilities(
        func: jobs_check,
        retval: *mut *mut doca_dev,
    ) -> doca_error_t;
}
extern "C" {
    pub fn open_doca_device_rep_with_vuid(
        local: *mut doca_dev,
        filter: doca_dev_rep_filter,
        value: *const u8,
        val_size: usize,
        retval: *mut *mut doca_dev_rep,
    ) -> doca_error_t;
}
extern "C" {
    pub fn open_doca_device_rep_with_pci(
        local: *mut doca_dev,
        filter: doca_dev_rep_filter,
        pci_bdf: *mut doca_pci_bdf,
        retval: *mut *mut doca_dev_rep,
    ) -> doca_error_t;
}
extern "C" {
    pub fn init_core_objects(
        state: *mut program_core_objects,
        extensions: u32,
        workq_depth: u32,
        max_chunks: u32,
    ) -> doca_error_t;
}
extern "C" {
    pub fn destroy_core_objects(state: *mut program_core_objects) -> doca_error_t;
}

extern "C" {
    pub fn hex_dump(
        data: *const ::std::os::raw::c_void,
        size: usize,
    ) -> *mut ::std::os::raw::c_char;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __locale_data {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct doca_mmap {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct doca_buf_inventory {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct doca_ctx {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct doca_workq {
    pub _address: u8,
}
