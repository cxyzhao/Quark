/* automatically generated by rust-bindgen 0.63.0 */

#[repr(C)]
#[derive(Copy, Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct __BindgenBitfieldUnit<Storage> {
    storage: Storage,
}
impl<Storage> __BindgenBitfieldUnit<Storage> {
    #[inline]
    pub const fn new(storage: Storage) -> Self {
        Self { storage }
    }
}
impl<Storage> __BindgenBitfieldUnit<Storage>
where
    Storage: AsRef<[u8]> + AsMut<[u8]>,
{
    #[inline]
    pub fn get_bit(&self, index: usize) -> bool {
        debug_assert!(index / 8 < self.storage.as_ref().len());
        let byte_index = index / 8;
        let byte = self.storage.as_ref()[byte_index];
        let bit_index = if cfg!(target_endian = "big") {
            7 - (index % 8)
        } else {
            index % 8
        };
        let mask = 1 << bit_index;
        byte & mask == mask
    }
    #[inline]
    pub fn set_bit(&mut self, index: usize, val: bool) {
        debug_assert!(index / 8 < self.storage.as_ref().len());
        let byte_index = index / 8;
        let byte = &mut self.storage.as_mut()[byte_index];
        let bit_index = if cfg!(target_endian = "big") {
            7 - (index % 8)
        } else {
            index % 8
        };
        let mask = 1 << bit_index;
        if val {
            *byte |= mask;
        } else {
            *byte &= !mask;
        }
    }
    #[inline]
    pub fn get(&self, bit_offset: usize, bit_width: u8) -> u64 {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());
        let mut val = 0;
        for i in 0..(bit_width as usize) {
            if self.get_bit(i + bit_offset) {
                let index = if cfg!(target_endian = "big") {
                    bit_width as usize - 1 - i
                } else {
                    i
                };
                val |= 1 << index;
            }
        }
        val
    }
    #[inline]
    pub fn set(&mut self, bit_offset: usize, bit_width: u8, val: u64) {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());
        for i in 0..(bit_width as usize) {
            let mask = 1 << i;
            let val_bit_is_set = val & mask == mask;
            let index = if cfg!(target_endian = "big") {
                bit_width as usize - 1 - i
            } else {
                i
            };
            self.set_bit(index + bit_offset, val_bit_is_set);
        }
    }
}
pub const true_: u32 = 1;
pub const false_: u32 = 0;
pub const __bool_true_false_are_defined: u32 = 1;
pub const _STRING_H: u32 = 1;
pub const _FEATURES_H: u32 = 1;
pub const _DEFAULT_SOURCE: u32 = 1;
pub const __GLIBC_USE_ISOC2X: u32 = 0;
pub const __USE_ISOC11: u32 = 1;
pub const __USE_ISOC99: u32 = 1;
pub const __USE_ISOC95: u32 = 1;
pub const __USE_POSIX_IMPLICITLY: u32 = 1;
pub const _POSIX_SOURCE: u32 = 1;
pub const _POSIX_C_SOURCE: u32 = 200809;
pub const __USE_POSIX: u32 = 1;
pub const __USE_POSIX2: u32 = 1;
pub const __USE_POSIX199309: u32 = 1;
pub const __USE_POSIX199506: u32 = 1;
pub const __USE_XOPEN2K: u32 = 1;
pub const __USE_XOPEN2K8: u32 = 1;
pub const _ATFILE_SOURCE: u32 = 1;
pub const __USE_MISC: u32 = 1;
pub const __USE_ATFILE: u32 = 1;
pub const __USE_FORTIFY_LEVEL: u32 = 0;
pub const __GLIBC_USE_DEPRECATED_GETS: u32 = 0;
pub const __GLIBC_USE_DEPRECATED_SCANF: u32 = 0;
pub const _STDC_PREDEF_H: u32 = 1;
pub const __STDC_IEC_559__: u32 = 1;
pub const __STDC_IEC_559_COMPLEX__: u32 = 1;
pub const __STDC_ISO_10646__: u32 = 201706;
pub const __GNU_LIBRARY__: u32 = 6;
pub const __GLIBC__: u32 = 2;
pub const __GLIBC_MINOR__: u32 = 31;
pub const _SYS_CDEFS_H: u32 = 1;
pub const __glibc_c99_flexarr_available: u32 = 1;
pub const __WORDSIZE: u32 = 64;
pub const __WORDSIZE_TIME64_COMPAT32: u32 = 1;
pub const __SYSCALL_WORDSIZE: u32 = 64;
pub const __LONG_DOUBLE_USES_FLOAT128: u32 = 0;
pub const __HAVE_GENERIC_SELECTION: u32 = 1;
pub const __GLIBC_USE_LIB_EXT2: u32 = 0;
pub const __GLIBC_USE_IEC_60559_BFP_EXT: u32 = 0;
pub const __GLIBC_USE_IEC_60559_BFP_EXT_C2X: u32 = 0;
pub const __GLIBC_USE_IEC_60559_FUNCS_EXT: u32 = 0;
pub const __GLIBC_USE_IEC_60559_FUNCS_EXT_C2X: u32 = 0;
pub const __GLIBC_USE_IEC_60559_TYPES_EXT: u32 = 0;
pub const _BITS_TYPES_LOCALE_T_H: u32 = 1;
pub const _BITS_TYPES___LOCALE_T_H: u32 = 1;
pub const _STRINGS_H: u32 = 1;
pub const _STDINT_H: u32 = 1;
pub const _BITS_TYPES_H: u32 = 1;
pub const __TIMESIZE: u32 = 64;
pub const _BITS_TYPESIZES_H: u32 = 1;
pub const __OFF_T_MATCHES_OFF64_T: u32 = 1;
pub const __INO_T_MATCHES_INO64_T: u32 = 1;
pub const __RLIM_T_MATCHES_RLIM64_T: u32 = 1;
pub const __STATFS_MATCHES_STATFS64: u32 = 1;
pub const __FD_SETSIZE: u32 = 1024;
pub const _BITS_TIME64_H: u32 = 1;
pub const _BITS_WCHAR_H: u32 = 1;
pub const _BITS_STDINT_INTN_H: u32 = 1;
pub const _BITS_STDINT_UINTN_H: u32 = 1;
pub const INT8_MIN: i32 = -128;
pub const INT16_MIN: i32 = -32768;
pub const INT32_MIN: i32 = -2147483648;
pub const INT8_MAX: u32 = 127;
pub const INT16_MAX: u32 = 32767;
pub const INT32_MAX: u32 = 2147483647;
pub const UINT8_MAX: u32 = 255;
pub const UINT16_MAX: u32 = 65535;
pub const UINT32_MAX: u32 = 4294967295;
pub const INT_LEAST8_MIN: i32 = -128;
pub const INT_LEAST16_MIN: i32 = -32768;
pub const INT_LEAST32_MIN: i32 = -2147483648;
pub const INT_LEAST8_MAX: u32 = 127;
pub const INT_LEAST16_MAX: u32 = 32767;
pub const INT_LEAST32_MAX: u32 = 2147483647;
pub const UINT_LEAST8_MAX: u32 = 255;
pub const UINT_LEAST16_MAX: u32 = 65535;
pub const UINT_LEAST32_MAX: u32 = 4294967295;
pub const INT_FAST8_MIN: i32 = -128;
pub const INT_FAST16_MIN: i64 = -9223372036854775808;
pub const INT_FAST32_MIN: i64 = -9223372036854775808;
pub const INT_FAST8_MAX: u32 = 127;
pub const INT_FAST16_MAX: u64 = 9223372036854775807;
pub const INT_FAST32_MAX: u64 = 9223372036854775807;
pub const UINT_FAST8_MAX: u32 = 255;
pub const UINT_FAST16_MAX: i32 = -1;
pub const UINT_FAST32_MAX: i32 = -1;
pub const INTPTR_MIN: i64 = -9223372036854775808;
pub const INTPTR_MAX: u64 = 9223372036854775807;
pub const UINTPTR_MAX: i32 = -1;
pub const PTRDIFF_MIN: i64 = -9223372036854775808;
pub const PTRDIFF_MAX: u64 = 9223372036854775807;
pub const SIG_ATOMIC_MIN: i32 = -2147483648;
pub const SIG_ATOMIC_MAX: u32 = 2147483647;
pub const SIZE_MAX: i32 = -1;
pub const WINT_MIN: u32 = 0;
pub const WINT_MAX: u32 = 4294967295;
pub const DOCA_VER_MAJOR: u32 = 1;
pub const DOCA_VER_MINOR: u32 = 5;
pub const DOCA_VER_PATCH: u32 = 55;
pub const DOCA_VER_STRING: &[u8; 9usize] = b"1.5.0055\0";
pub const doca_event_invalid_handle: i32 = -1;
pub const PCI_FUNCTION_MAX_VALUE: u32 = 8;
pub const PCI_DEVICE_MAX_VALUE: u32 = 32;
pub const PCI_BUS_MAX_VALUE: u32 = 256;
pub const DOCA_DEVINFO_VUID_SIZE: u32 = 128;
pub const DOCA_DEVINFO_IPV4_ADDR_SIZE: u32 = 4;
pub const DOCA_DEVINFO_IPV6_ADDR_SIZE: u32 = 16;
pub const DOCA_DEVINFO_IFACE_NAME_SIZE: u32 = 256;
pub const DOCA_DEVINFO_IBDEV_NAME_SIZE: u32 = 64;
pub const DOCA_DEVINFO_REP_VUID_SIZE: u32 = 128;
pub const _STDIO_H: u32 = 1;
pub const __GNUC_VA_LIST: u32 = 1;
pub const _____fpos_t_defined: u32 = 1;
pub const ____mbstate_t_defined: u32 = 1;
pub const _____fpos64_t_defined: u32 = 1;
pub const ____FILE_defined: u32 = 1;
pub const __FILE_defined: u32 = 1;
pub const __struct_FILE_defined: u32 = 1;
pub const _IO_EOF_SEEN: u32 = 16;
pub const _IO_ERR_SEEN: u32 = 32;
pub const _IO_USER_LOCK: u32 = 32768;
pub const _IOFBF: u32 = 0;
pub const _IOLBF: u32 = 1;
pub const _IONBF: u32 = 2;
pub const BUFSIZ: u32 = 8192;
pub const EOF: i32 = -1;
pub const SEEK_SET: u32 = 0;
pub const SEEK_CUR: u32 = 1;
pub const SEEK_END: u32 = 2;
pub const P_tmpdir: &[u8; 5usize] = b"/tmp\0";
pub const _BITS_STDIO_LIM_H: u32 = 1;
pub const L_tmpnam: u32 = 20;
pub const TMP_MAX: u32 = 238328;
pub const FILENAME_MAX: u32 = 4096;
pub const L_ctermid: u32 = 9;
pub const FOPEN_MAX: u32 = 16;
pub const MAX_ARG_SIZE: u32 = 128;
pub const MAX_DMA_BUF_SIZE: u32 = 1048576;
pub const CC_MAX_MSG_SIZE: u32 = 4080;
pub const PCI_ADDR_LEN: u32 = 8;
pub const SERVER_NAME: &[u8; 16usize] = b"dma copy server\0";
extern "C" {
    pub fn memcpy(
        __dest: *mut ::std::os::raw::c_void,
        __src: *const ::std::os::raw::c_void,
        __n: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn memmove(
        __dest: *mut ::std::os::raw::c_void,
        __src: *const ::std::os::raw::c_void,
        __n: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn memccpy(
        __dest: *mut ::std::os::raw::c_void,
        __src: *const ::std::os::raw::c_void,
        __c: ::std::os::raw::c_int,
        __n: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn memset(
        __s: *mut ::std::os::raw::c_void,
        __c: ::std::os::raw::c_int,
        __n: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn memcmp(
        __s1: *const ::std::os::raw::c_void,
        __s2: *const ::std::os::raw::c_void,
        __n: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn memchr(
        __s: *const ::std::os::raw::c_void,
        __c: ::std::os::raw::c_int,
        __n: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn strcpy(
        __dest: *mut ::std::os::raw::c_char,
        __src: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strncpy(
        __dest: *mut ::std::os::raw::c_char,
        __src: *const ::std::os::raw::c_char,
        __n: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strcat(
        __dest: *mut ::std::os::raw::c_char,
        __src: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strncat(
        __dest: *mut ::std::os::raw::c_char,
        __src: *const ::std::os::raw::c_char,
        __n: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strcmp(
        __s1: *const ::std::os::raw::c_char,
        __s2: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strncmp(
        __s1: *const ::std::os::raw::c_char,
        __s2: *const ::std::os::raw::c_char,
        __n: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strcoll(
        __s1: *const ::std::os::raw::c_char,
        __s2: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strxfrm(
        __dest: *mut ::std::os::raw::c_char,
        __src: *const ::std::os::raw::c_char,
        __n: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_ulong;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __locale_struct {
    pub __locales: [*mut __locale_data; 13usize],
    pub __ctype_b: *const ::std::os::raw::c_ushort,
    pub __ctype_tolower: *const ::std::os::raw::c_int,
    pub __ctype_toupper: *const ::std::os::raw::c_int,
    pub __names: [*const ::std::os::raw::c_char; 13usize],
}
#[test]
fn bindgen_test_layout___locale_struct() {
    const UNINIT: ::std::mem::MaybeUninit<__locale_struct> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__locale_struct>(),
        232usize,
        concat!("Size of: ", stringify!(__locale_struct))
    );
    assert_eq!(
        ::std::mem::align_of::<__locale_struct>(),
        8usize,
        concat!("Alignment of ", stringify!(__locale_struct))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__locales) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__locale_struct),
            "::",
            stringify!(__locales)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__ctype_b) as usize - ptr as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(__locale_struct),
            "::",
            stringify!(__ctype_b)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__ctype_tolower) as usize - ptr as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(__locale_struct),
            "::",
            stringify!(__ctype_tolower)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__ctype_toupper) as usize - ptr as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(__locale_struct),
            "::",
            stringify!(__ctype_toupper)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__names) as usize - ptr as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(__locale_struct),
            "::",
            stringify!(__names)
        )
    );
}
pub type __locale_t = *mut __locale_struct;
pub type locale_t = __locale_t;
extern "C" {
    pub fn strcoll_l(
        __s1: *const ::std::os::raw::c_char,
        __s2: *const ::std::os::raw::c_char,
        __l: locale_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strxfrm_l(
        __dest: *mut ::std::os::raw::c_char,
        __src: *const ::std::os::raw::c_char,
        __n: usize,
        __l: locale_t,
    ) -> usize;
}
extern "C" {
    pub fn strdup(__s: *const ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strndup(
        __string: *const ::std::os::raw::c_char,
        __n: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strchr(
        __s: *const ::std::os::raw::c_char,
        __c: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strrchr(
        __s: *const ::std::os::raw::c_char,
        __c: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strcspn(
        __s: *const ::std::os::raw::c_char,
        __reject: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn strspn(
        __s: *const ::std::os::raw::c_char,
        __accept: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn strpbrk(
        __s: *const ::std::os::raw::c_char,
        __accept: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strstr(
        __haystack: *const ::std::os::raw::c_char,
        __needle: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strtok(
        __s: *mut ::std::os::raw::c_char,
        __delim: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn __strtok_r(
        __s: *mut ::std::os::raw::c_char,
        __delim: *const ::std::os::raw::c_char,
        __save_ptr: *mut *mut ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strtok_r(
        __s: *mut ::std::os::raw::c_char,
        __delim: *const ::std::os::raw::c_char,
        __save_ptr: *mut *mut ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strlen(__s: *const ::std::os::raw::c_char) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn strnlen(__string: *const ::std::os::raw::c_char, __maxlen: usize) -> usize;
}
extern "C" {
    pub fn strerror(__errnum: ::std::os::raw::c_int) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    #[link_name = "\u{1}__xpg_strerror_r"]
    pub fn strerror_r(
        __errnum: ::std::os::raw::c_int,
        __buf: *mut ::std::os::raw::c_char,
        __buflen: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strerror_l(
        __errnum: ::std::os::raw::c_int,
        __l: locale_t,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn bcmp(
        __s1: *const ::std::os::raw::c_void,
        __s2: *const ::std::os::raw::c_void,
        __n: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn bcopy(
        __src: *const ::std::os::raw::c_void,
        __dest: *mut ::std::os::raw::c_void,
        __n: usize,
    );
}
extern "C" {
    pub fn bzero(__s: *mut ::std::os::raw::c_void, __n: ::std::os::raw::c_ulong);
}
extern "C" {
    pub fn index(
        __s: *const ::std::os::raw::c_char,
        __c: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn rindex(
        __s: *const ::std::os::raw::c_char,
        __c: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn ffs(__i: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ffsl(__l: ::std::os::raw::c_long) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ffsll(__ll: ::std::os::raw::c_longlong) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strcasecmp(
        __s1: *const ::std::os::raw::c_char,
        __s2: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strncasecmp(
        __s1: *const ::std::os::raw::c_char,
        __s2: *const ::std::os::raw::c_char,
        __n: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strcasecmp_l(
        __s1: *const ::std::os::raw::c_char,
        __s2: *const ::std::os::raw::c_char,
        __loc: locale_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strncasecmp_l(
        __s1: *const ::std::os::raw::c_char,
        __s2: *const ::std::os::raw::c_char,
        __n: usize,
        __loc: locale_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn explicit_bzero(__s: *mut ::std::os::raw::c_void, __n: usize);
}
extern "C" {
    pub fn strsep(
        __stringp: *mut *mut ::std::os::raw::c_char,
        __delim: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strsignal(__sig: ::std::os::raw::c_int) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn __stpcpy(
        __dest: *mut ::std::os::raw::c_char,
        __src: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn stpcpy(
        __dest: *mut ::std::os::raw::c_char,
        __src: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn __stpncpy(
        __dest: *mut ::std::os::raw::c_char,
        __src: *const ::std::os::raw::c_char,
        __n: usize,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn stpncpy(
        __dest: *mut ::std::os::raw::c_char,
        __src: *const ::std::os::raw::c_char,
        __n: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_char;
}
pub type __u_char = ::std::os::raw::c_uchar;
pub type __u_short = ::std::os::raw::c_ushort;
pub type __u_int = ::std::os::raw::c_uint;
pub type __u_long = ::std::os::raw::c_ulong;
pub type __int8_t = ::std::os::raw::c_schar;
pub type __uint8_t = ::std::os::raw::c_uchar;
pub type __int16_t = ::std::os::raw::c_short;
pub type __uint16_t = ::std::os::raw::c_ushort;
pub type __int32_t = ::std::os::raw::c_int;
pub type __uint32_t = ::std::os::raw::c_uint;
pub type __int64_t = ::std::os::raw::c_long;
pub type __uint64_t = ::std::os::raw::c_ulong;
pub type __int_least8_t = __int8_t;
pub type __uint_least8_t = __uint8_t;
pub type __int_least16_t = __int16_t;
pub type __uint_least16_t = __uint16_t;
pub type __int_least32_t = __int32_t;
pub type __uint_least32_t = __uint32_t;
pub type __int_least64_t = __int64_t;
pub type __uint_least64_t = __uint64_t;
pub type __quad_t = ::std::os::raw::c_long;
pub type __u_quad_t = ::std::os::raw::c_ulong;
pub type __intmax_t = ::std::os::raw::c_long;
pub type __uintmax_t = ::std::os::raw::c_ulong;
pub type __dev_t = ::std::os::raw::c_ulong;
pub type __uid_t = ::std::os::raw::c_uint;
pub type __gid_t = ::std::os::raw::c_uint;
pub type __ino_t = ::std::os::raw::c_ulong;
pub type __ino64_t = ::std::os::raw::c_ulong;
pub type __mode_t = ::std::os::raw::c_uint;
pub type __nlink_t = ::std::os::raw::c_ulong;
pub type __off_t = ::std::os::raw::c_long;
pub type __off64_t = ::std::os::raw::c_long;
pub type __pid_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __fsid_t {
    pub __val: [::std::os::raw::c_int; 2usize],
}
#[test]
fn bindgen_test_layout___fsid_t() {
    const UNINIT: ::std::mem::MaybeUninit<__fsid_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__fsid_t>(),
        8usize,
        concat!("Size of: ", stringify!(__fsid_t))
    );
    assert_eq!(
        ::std::mem::align_of::<__fsid_t>(),
        4usize,
        concat!("Alignment of ", stringify!(__fsid_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__val) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__fsid_t),
            "::",
            stringify!(__val)
        )
    );
}
pub type __clock_t = ::std::os::raw::c_long;
pub type __rlim_t = ::std::os::raw::c_ulong;
pub type __rlim64_t = ::std::os::raw::c_ulong;
pub type __id_t = ::std::os::raw::c_uint;
pub type __time_t = ::std::os::raw::c_long;
pub type __useconds_t = ::std::os::raw::c_uint;
pub type __suseconds_t = ::std::os::raw::c_long;
pub type __daddr_t = ::std::os::raw::c_int;
pub type __key_t = ::std::os::raw::c_int;
pub type __clockid_t = ::std::os::raw::c_int;
pub type __timer_t = *mut ::std::os::raw::c_void;
pub type __blksize_t = ::std::os::raw::c_long;
pub type __blkcnt_t = ::std::os::raw::c_long;
pub type __blkcnt64_t = ::std::os::raw::c_long;
pub type __fsblkcnt_t = ::std::os::raw::c_ulong;
pub type __fsblkcnt64_t = ::std::os::raw::c_ulong;
pub type __fsfilcnt_t = ::std::os::raw::c_ulong;
pub type __fsfilcnt64_t = ::std::os::raw::c_ulong;
pub type __fsword_t = ::std::os::raw::c_long;
pub type __ssize_t = ::std::os::raw::c_long;
pub type __syscall_slong_t = ::std::os::raw::c_long;
pub type __syscall_ulong_t = ::std::os::raw::c_ulong;
pub type __loff_t = __off64_t;
pub type __caddr_t = *mut ::std::os::raw::c_char;
pub type __intptr_t = ::std::os::raw::c_long;
pub type __socklen_t = ::std::os::raw::c_uint;
pub type __sig_atomic_t = ::std::os::raw::c_int;
pub type int_least8_t = __int_least8_t;
pub type int_least16_t = __int_least16_t;
pub type int_least32_t = __int_least32_t;
pub type int_least64_t = __int_least64_t;
pub type uint_least8_t = __uint_least8_t;
pub type uint_least16_t = __uint_least16_t;
pub type uint_least32_t = __uint_least32_t;
pub type uint_least64_t = __uint_least64_t;
pub type int_fast8_t = ::std::os::raw::c_schar;
pub type int_fast16_t = ::std::os::raw::c_long;
pub type int_fast32_t = ::std::os::raw::c_long;
pub type int_fast64_t = ::std::os::raw::c_long;
pub type uint_fast8_t = ::std::os::raw::c_uchar;
pub type uint_fast16_t = ::std::os::raw::c_ulong;
pub type uint_fast32_t = ::std::os::raw::c_ulong;
pub type uint_fast64_t = ::std::os::raw::c_ulong;
pub type intmax_t = __intmax_t;
pub type uintmax_t = __uintmax_t;
pub type wchar_t = ::std::os::raw::c_int;
#[repr(C)]
#[repr(align(16))]
#[derive(Debug, Copy, Clone)]
pub struct max_align_t {
    pub __clang_max_align_nonce1: ::std::os::raw::c_longlong,
    pub __bindgen_padding_0: u64,
    pub __clang_max_align_nonce2: u128,
}
#[test]
fn bindgen_test_layout_max_align_t() {
    const UNINIT: ::std::mem::MaybeUninit<max_align_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<max_align_t>(),
        32usize,
        concat!("Size of: ", stringify!(max_align_t))
    );
    assert_eq!(
        ::std::mem::align_of::<max_align_t>(),
        16usize,
        concat!("Alignment of ", stringify!(max_align_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__clang_max_align_nonce1) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(max_align_t),
            "::",
            stringify!(__clang_max_align_nonce1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__clang_max_align_nonce2) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(max_align_t),
            "::",
            stringify!(__clang_max_align_nonce2)
        )
    );
}
extern "C" {
    #[doc = " @brief Function returning DOCA's (runtime) version string.\n\n @return\n version string, using the format major.minor.patch.\n\n @note Represents the runtime version a project is linked against."]
    pub fn doca_version_runtime() -> *const ::std::os::raw::c_char;
}
pub const doca_error_DOCA_SUCCESS: doca_error = 0;
pub const doca_error_DOCA_ERROR_UNKNOWN: doca_error = 1;
#[doc = "< Operation not permitted"]
pub const doca_error_DOCA_ERROR_NOT_PERMITTED: doca_error = 2;
#[doc = "< Resource already in use"]
pub const doca_error_DOCA_ERROR_IN_USE: doca_error = 3;
#[doc = "< Operation not supported"]
pub const doca_error_DOCA_ERROR_NOT_SUPPORTED: doca_error = 4;
#[doc = "< Resource temporarily unavailable, try again"]
pub const doca_error_DOCA_ERROR_AGAIN: doca_error = 5;
#[doc = "< Invalid input"]
pub const doca_error_DOCA_ERROR_INVALID_VALUE: doca_error = 6;
#[doc = "< Memory allocation failure"]
pub const doca_error_DOCA_ERROR_NO_MEMORY: doca_error = 7;
#[doc = "< Resource initialization failure"]
pub const doca_error_DOCA_ERROR_INITIALIZATION: doca_error = 8;
#[doc = "< Timer expired waiting for resource"]
pub const doca_error_DOCA_ERROR_TIME_OUT: doca_error = 9;
#[doc = "< Shut down in process or completed"]
pub const doca_error_DOCA_ERROR_SHUTDOWN: doca_error = 10;
#[doc = "< Connection reset by peer"]
pub const doca_error_DOCA_ERROR_CONNECTION_RESET: doca_error = 11;
#[doc = "< Connection aborted"]
pub const doca_error_DOCA_ERROR_CONNECTION_ABORTED: doca_error = 12;
#[doc = "< Connection in progress"]
pub const doca_error_DOCA_ERROR_CONNECTION_INPROGRESS: doca_error = 13;
#[doc = "< Not Connected"]
pub const doca_error_DOCA_ERROR_NOT_CONNECTED: doca_error = 14;
#[doc = "< Unable to acquire required lock"]
pub const doca_error_DOCA_ERROR_NO_LOCK: doca_error = 15;
#[doc = "< Resource Not Found"]
pub const doca_error_DOCA_ERROR_NOT_FOUND: doca_error = 16;
#[doc = "< Input/Output Operation Failed"]
pub const doca_error_DOCA_ERROR_IO_FAILED: doca_error = 17;
#[doc = "< Bad State"]
pub const doca_error_DOCA_ERROR_BAD_STATE: doca_error = 18;
#[doc = "< Unsupported version"]
pub const doca_error_DOCA_ERROR_UNSUPPORTED_VERSION: doca_error = 19;
#[doc = "< Operating system call failure"]
pub const doca_error_DOCA_ERROR_OPERATING_SYSTEM: doca_error = 20;
#[doc = "< DOCA Driver call failure"]
pub const doca_error_DOCA_ERROR_DRIVER: doca_error = 21;
#[doc = "< An unexpected scenario was detected"]
pub const doca_error_DOCA_ERROR_UNEXPECTED: doca_error = 22;
pub type doca_error = ::std::os::raw::c_uint;
pub use self::doca_error as doca_error_t;
extern "C" {
    #[doc = " \\brief Returns the string representation of an error code name.\n\n Returns a string containing the name of an error code in the enum.\n If the error code is not recognized, \"unrecognized error code\" is returned.\n\n @param[in] error - Error code to convert to string.\n\n @return char* pointer to a NULL-terminated string."]
    pub fn doca_get_error_name(error: doca_error_t) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " \\brief Returns the description string of an error code.\n\n  This function returns the description string of an error code.\n  If the error code is not recognized, \"unrecognized error code\" is returned.\n\n @param[in] error - Error code to convert to description string.\n\n @return char* pointer to a NULL-terminated string."]
    pub fn doca_get_error_string(error: doca_error_t) -> *const ::std::os::raw::c_char;
}
#[doc = " @brief Flag callback function type"]
pub type callback_func = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: *mut ::std::os::raw::c_void,
        arg2: *mut ::std::os::raw::c_void,
    ) -> doca_error_t,
>;
#[doc = " @brief DPDK flags callback function type"]
pub type dpdk_callback = ::std::option::Option<
    unsafe extern "C" fn(
        argc: ::std::os::raw::c_int,
        argv: *mut *mut ::std::os::raw::c_char,
    ) -> doca_error_t,
>;
#[doc = " @brief Program validation callback function type"]
pub type validation_callback =
    ::std::option::Option<unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void) -> doca_error_t>;
pub const doca_argp_type_DOCA_ARGP_TYPE_UNKNOWN: doca_argp_type = 0;
#[doc = "< Input type is a string"]
pub const doca_argp_type_DOCA_ARGP_TYPE_STRING: doca_argp_type = 1;
#[doc = "< Input type is an integer"]
pub const doca_argp_type_DOCA_ARGP_TYPE_INT: doca_argp_type = 2;
#[doc = "< Input type is a boolean"]
pub const doca_argp_type_DOCA_ARGP_TYPE_BOOLEAN: doca_argp_type = 3;
#[doc = "< DPDK Param input type is a json object,\n only for json mode"]
pub const doca_argp_type_DOCA_ARGP_TYPE_JSON_OBJ: doca_argp_type = 4;
#[doc = " @brief Flag input type"]
pub type doca_argp_type = ::std::os::raw::c_uint;
#[doc = " @brief Program flag information\n\n @note It is the programmer's responsibility to ensure the callback will copy the content of the param passed to it.\n The pointer pointing to the param is owned by doca_argp, and it is only valid in the scope of the called callback."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct doca_argp_param {
    _unused: [u8; 0],
}
extern "C" {
    #[doc = " @brief Print usage instructions."]
    pub fn doca_argp_usage();
}
extern "C" {
    #[doc = " @brief Initialize the parser interface.\n\n @param [in] program_name\n Name of current program, using the name for usage print.\n @param [in] program_config\n Program configuration struct.\n\n @return\n DOCA_SUCCESS - in case of success.\n Error code - in case of failure:\n - DOCA_ERROR_INVALID_VALUE - received invalid input.\n @note After a successful call to this function, doca_argp_destroy() should be called as part of program cleanup."]
    pub fn doca_argp_init(
        program_name: *const ::std::os::raw::c_char,
        program_config: *mut ::std::os::raw::c_void,
    ) -> doca_error_t;
}
extern "C" {
    #[doc = " @brief Register a program flag.\n\n @param [in] input_param\n Program flag details.\n\n @return\n DOCA_SUCCESS - in case of success.\n Error code - in case of failure:\n - DOCA_ERROR_INVALID_VALUE - received invalid input.\n - DOCA_ERROR_INITIALIZATION - received param with missing mandatory fields initialization.\n @note Value of is_cli_only field may be changed in this function.\n @note ARGP takes ownership of the pointer and will free the param including in case of failure."]
    pub fn doca_argp_register_param(input_param: *mut doca_argp_param) -> doca_error_t;
}
extern "C" {
    #[doc = " @brief Register an alternative version callback.\n\n @param [in] callback\n Program-specific version callback.\n\n @return\n DOCA_SUCCESS - in case of success.\n Error code - in case of failure:\n - DOCA_ERROR_INVALID_VALUE - received invalid input."]
    pub fn doca_argp_register_version_callback(callback: callback_func) -> doca_error_t;
}
extern "C" {
    #[doc = " @brief Register program validation callback function.\n\n @param [in] callback\n Program validation callback.\n\n @return\n DOCA_SUCCESS - in case of success.\n Error code - in case of failure:\n - DOCA_ERROR_INVALID_VALUE - received invalid input.\n\n @note When calling validation callback, will pass one argument which is the program configuration struct."]
    pub fn doca_argp_register_validation_callback(callback: validation_callback) -> doca_error_t;
}
extern "C" {
    #[doc = " @brief Parse incoming arguments (cmd line/json).\n\n @param [in] argc\n Number of program command line arguments.\n @param [in] argv\n Program command line arguments.\n\n @return\n DOCA_SUCCESS - in case of success.\n Error code - in case of failure:\n - DOCA_ERROR_NOT_SUPPORTED - received unsupported program flag.\n - DOCA_ERROR_INVALID_VALUE - received invalid input.\n - DOCA_ERROR_IO_FAILED - Internal errors about JSON API, reading JSON content.\n - DOCA_ERROR_NO_MEMORY - failed to allocate enough space.\n - DOCA_ERROR_INITIALIZATION - initialization error.\n @note: if the program is based on DPDK API, DPDK flags will be forwarded to it by calling the registered callback."]
    pub fn doca_argp_start(
        argc: ::std::os::raw::c_int,
        argv: *mut *mut ::std::os::raw::c_char,
    ) -> doca_error_t;
}
extern "C" {
    #[doc = " @brief ARG Parser destroy.\n\n cleanup all resources including the parsed DPDK flags, the program can't use them any more."]
    pub fn doca_argp_destroy() -> doca_error_t;
}
extern "C" {
    #[doc = " @brief Set information about program configuration, if it's based on DPDK API.\n\n @param [in] callback\n Once ARGP finished parsing DPDK flags will be forwarded to the program by calling this callback.\n\n @note Need to call doca_argp_init before setting program DPDK type.\n @note If program is based on DPDK API, DPDK flags array will be sent using the callback,\n the array will be released when calling doca_argp_destroy."]
    pub fn doca_argp_set_dpdk_program(callback: dpdk_callback);
}
extern "C" {
    #[doc = " @brief Set information about program configuration, if it's based on gRPC API.\n\n @note Need to call doca_argp_init before setting program gRPC type."]
    pub fn doca_argp_set_grpc_program();
}
extern "C" {
    #[doc = " @brief Create new program param.\n\n @param [out] param\n Create program param instance on success. Valid on success only.\n\n @note Need to set param fields by setter functions."]
    pub fn doca_argp_param_create(param: *mut *mut doca_argp_param) -> doca_error_t;
}
extern "C" {
    #[doc = " @brief Set the short name of the program param.\n\n @param [in] param\n The program param.\n @param [in] name\n The param's short name\n\n @note Passing a \"param\" value of NULL will result in an undefined behavior.\n @note At least one of param names should be set."]
    pub fn doca_argp_param_set_short_name(
        param: *mut doca_argp_param,
        name: *const ::std::os::raw::c_char,
    );
}
extern "C" {
    #[doc = " @brief Set the long name of the program param.\n\n @param [in] param\n The program param.\n @param [in] name\n The param's long name.\n\n @note Passing a \"param\" value of NULL will result in an undefined behavior.\n @note At least one of param names should be set."]
    pub fn doca_argp_param_set_long_name(
        param: *mut doca_argp_param,
        name: *const ::std::os::raw::c_char,
    );
}
extern "C" {
    #[doc = " @brief Set the expected arguments of the program param, used to print the program usage.\n\n @param [in] param\n The program param.\n @param [in] arguments\n The param's arguments.\n @note Passing a \"param\" value of NULL will result in an undefined behavior."]
    pub fn doca_argp_param_set_arguments(
        param: *mut doca_argp_param,
        arguments: *const ::std::os::raw::c_char,
    );
}
extern "C" {
    #[doc = " @brief Set the description of the program param, used to print the program usage.\n\n @param [in] param\n The program param.\n @param [in] description\n The param's description.\n\n @note Passing a \"param\" value of NULL will result in an undefined behavior.\n @note Set param description is mandatory."]
    pub fn doca_argp_param_set_description(
        param: *mut doca_argp_param,
        description: *const ::std::os::raw::c_char,
    );
}
extern "C" {
    #[doc = " @brief Set the callback function of the program param.\n\n @param [in] param\n The program param.\n @param [in] callback\n The param's callback function.\n\n @note Passing a \"param\" value of NULL will result in an undefined behavior.\n @note Once ARGP identifies this param in CLI, will call the callback function with attaching the param argument value\n as first argument and next the program configuration struct. Program should copy the argument value and shouldn't\n use it directly.\n @note Set param callback is mandatory."]
    pub fn doca_argp_param_set_callback(param: *mut doca_argp_param, callback: callback_func);
}
extern "C" {
    #[doc = " @brief Set the type of the param arguments.\n\n @param [in] param\n The program param.\n @param [in] type\n The param arguments type.\n\n @note Passing a \"param\" value of NULL will result in an undefined behavior.\n @note Set param arguments type is mandatory."]
    pub fn doca_argp_param_set_type(param: *mut doca_argp_param, type_: doca_argp_type);
}
extern "C" {
    #[doc = " @brief Set if the program param is mandatory, by default the value is false.\n\n @param [in] param\n The program param.\n\n @note Passing a \"param\" value of NULL will result in an undefined behavior."]
    pub fn doca_argp_param_set_mandatory(param: *mut doca_argp_param);
}
extern "C" {
    #[doc = " @brief Set if the program param is supported only CLI mode and will not be used in JSON file, by default the value\n is false.\n\n @param [in] param\n The program param.\n\n @note Passing a \"param\" value of NULL will result in an undefined behavior."]
    pub fn doca_argp_param_set_cli_only(param: *mut doca_argp_param);
}
extern "C" {
    #[doc = " @brief Destroy a program param.\n\n @param [in] param\n The program param to destroy.\n\n @return\n DOCA_SUCCESS - in case of success.\n Error code - in case of failure:\n - DOCA_ERROR_INVALID_VALUE - invalid input received."]
    pub fn doca_argp_param_destroy(param: *mut doca_argp_param) -> doca_error_t;
}
extern "C" {
    #[doc = " @brief Get the address of a gRPC server as the user inserted it.\n\n @param [out] address\n gRPC address.\n\n DOCA_SUCCESS - in case of success.\n Error code - in case of failure:\n - DOCA_ERROR_INVALID_VALUE - invalid input received.\n @note: No need to copy the returned gRPC address."]
    pub fn doca_argp_get_grpc_addr(address: *mut *const ::std::os::raw::c_char) -> doca_error_t;
}
extern "C" {
    #[doc = " @brief Get the log level the user inserted it.\n\n @param [out] log_level\n The log level if the user inserted it, otherwise the default value of log level.\n\n DOCA_SUCCESS - in case of success.\n Error code - in case of failure:\n - DOCA_ERROR_INVALID_VALUE - invalid input received."]
    pub fn doca_argp_get_log_level(log_level: *mut ::std::os::raw::c_int) -> doca_error_t;
}
pub type doca_event_handle_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Copy, Clone)]
pub union doca_data {
    pub ptr: *mut ::std::os::raw::c_void,
    pub u64_: u64,
}
#[test]
fn bindgen_test_layout_doca_data() {
    const UNINIT: ::std::mem::MaybeUninit<doca_data> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<doca_data>(),
        8usize,
        concat!("Size of: ", stringify!(doca_data))
    );
    assert_eq!(
        ::std::mem::align_of::<doca_data>(),
        8usize,
        concat!("Alignment of ", stringify!(doca_data))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ptr) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(doca_data),
            "::",
            stringify!(ptr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).u64_) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(doca_data),
            "::",
            stringify!(u64_)
        )
    );
}
pub const doca_access_flags_DOCA_ACCESS_LOCAL_READ: doca_access_flags = 0;
pub const doca_access_flags_DOCA_ACCESS_LOCAL_WRITE: doca_access_flags = 1;
pub const doca_access_flags_DOCA_ACCESS_REMOTE_WRITE: doca_access_flags = 2;
pub const doca_access_flags_DOCA_ACCESS_REMOTE_READ: doca_access_flags = 4;
pub const doca_access_flags_DOCA_ACCESS_REMOTE_ATOMIC: doca_access_flags = 8;
#[doc = " @brief Specifies the permission level for DOCA buffer\n"]
pub type doca_access_flags = ::std::os::raw::c_uint;
pub const doca_pci_func_type_DOCA_PCI_FUNC_PF: doca_pci_func_type = 0;
pub const doca_pci_func_type_DOCA_PCI_FUNC_VF: doca_pci_func_type = 1;
pub const doca_pci_func_type_DOCA_PCI_FUNC_SF: doca_pci_func_type = 2;
#[doc = " @brief Specifies the PCI function type for DOCA representor device\n"]
pub type doca_pci_func_type = ::std::os::raw::c_uint;
#[doc = " @brief The PCI address of a device - same as the address in lspci\n"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct doca_pci_bdf {
    pub __bindgen_anon_1: doca_pci_bdf__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union doca_pci_bdf__bindgen_ty_1 {
    pub raw: u16,
    pub __bindgen_anon_1: doca_pci_bdf__bindgen_ty_1__bindgen_ty_1,
}
#[repr(C)]
#[repr(align(2))]
#[derive(Debug, Copy, Clone)]
pub struct doca_pci_bdf__bindgen_ty_1__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize]>,
}
#[test]
fn bindgen_test_layout_doca_pci_bdf__bindgen_ty_1__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<doca_pci_bdf__bindgen_ty_1__bindgen_ty_1>(),
        2usize,
        concat!(
            "Size of: ",
            stringify!(doca_pci_bdf__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<doca_pci_bdf__bindgen_ty_1__bindgen_ty_1>(),
        2usize,
        concat!(
            "Alignment of ",
            stringify!(doca_pci_bdf__bindgen_ty_1__bindgen_ty_1)
        )
    );
}
impl doca_pci_bdf__bindgen_ty_1__bindgen_ty_1 {
    #[inline]
    pub fn bus(&self) -> u16 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 8u8) as u16) }
    }
    #[inline]
    pub fn set_bus(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn device(&self) -> u16 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(8usize, 5u8) as u16) }
    }
    #[inline]
    pub fn set_device(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(8usize, 5u8, val as u64)
        }
    }
    #[inline]
    pub fn function(&self) -> u16 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(13usize, 3u8) as u16) }
    }
    #[inline]
    pub fn set_function(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(13usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        bus: u16,
        device: u16,
        function: u16,
    ) -> __BindgenBitfieldUnit<[u8; 2usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 8u8, {
            let bus: u16 = unsafe { ::std::mem::transmute(bus) };
            bus as u64
        });
        __bindgen_bitfield_unit.set(8usize, 5u8, {
            let device: u16 = unsafe { ::std::mem::transmute(device) };
            device as u64
        });
        __bindgen_bitfield_unit.set(13usize, 3u8, {
            let function: u16 = unsafe { ::std::mem::transmute(function) };
            function as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_doca_pci_bdf__bindgen_ty_1() {
    const UNINIT: ::std::mem::MaybeUninit<doca_pci_bdf__bindgen_ty_1> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<doca_pci_bdf__bindgen_ty_1>(),
        2usize,
        concat!("Size of: ", stringify!(doca_pci_bdf__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<doca_pci_bdf__bindgen_ty_1>(),
        2usize,
        concat!("Alignment of ", stringify!(doca_pci_bdf__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).raw) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(doca_pci_bdf__bindgen_ty_1),
            "::",
            stringify!(raw)
        )
    );
}
#[test]
fn bindgen_test_layout_doca_pci_bdf() {
    assert_eq!(
        ::std::mem::size_of::<doca_pci_bdf>(),
        2usize,
        concat!("Size of: ", stringify!(doca_pci_bdf))
    );
    assert_eq!(
        ::std::mem::align_of::<doca_pci_bdf>(),
        2usize,
        concat!("Alignment of ", stringify!(doca_pci_bdf))
    );
}
#[doc = " @brief Opaque structure representing a local DOCA Device Info instance.\n This structure is used to query information about the local device."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct doca_devinfo {
    _unused: [u8; 0],
}
#[doc = " @brief Opaque structure representing a representor DOCA Device Info instance.\n This structure is used to query information about the representor device."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct doca_devinfo_rep {
    _unused: [u8; 0],
}
#[doc = " @brief Opaque structure representing a local DOCA Device instance.\n This structure is used by libraries for accessing the underlying local device."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct doca_dev {
    _unused: [u8; 0],
}
#[doc = " @brief Opaque structure representing a representor DOCA Device instance.\n This structure is used by libraries for accessing the underlying representor device."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct doca_dev_rep {
    _unused: [u8; 0],
}
pub const doca_dev_rep_filter_DOCA_DEV_REP_FILTER_ALL: doca_dev_rep_filter = 0;
pub const doca_dev_rep_filter_DOCA_DEV_REP_FILTER_NET: doca_dev_rep_filter = 2;
pub const doca_dev_rep_filter_DOCA_DEV_REP_FILTER_VIRTIO_FS: doca_dev_rep_filter = 4;
pub const doca_dev_rep_filter_DOCA_DEV_REP_FILTER_VIRTIO_NET: doca_dev_rep_filter = 8;
pub const doca_dev_rep_filter_DOCA_DEV_REP_FILTER_VIRTIO_BLK: doca_dev_rep_filter = 16;
pub const doca_dev_rep_filter_DOCA_DEV_REP_FILTER_NVME: doca_dev_rep_filter = 32;
#[doc = " Representor device filter by flavor\n\n Multiple options possible but some are mutually exclusive.\n"]
pub type doca_dev_rep_filter = ::std::os::raw::c_uint;
extern "C" {
    #[doc = " @brief Creates list of all available local devices.\n\n Lists information about available devices, to start using the device you first have to call doca_dev_open(),\n while passing an element of this list. List elements become invalid once it has been destroyed.\n\n @param [out] dev_list\n Pointer to array of pointers. Output can then be accessed as follows (*dev_list)[idx].\n @param [out] nb_devs\n Number of available local devices.\n\n @return\n DOCA_SUCCESS - in case of success.\n Error code - in case of failure:\n - DOCA_ERROR_INVALID_VALUE - received invalid input.\n - DOCA_ERROR_NO_MEMORY - failed to allocate enough space.\n - DOCA_ERROR_NOT_FOUND - failed to get RDMA devices list\n @note Returned list must be destroyed using doca_devinfo_list_destroy()"]
    pub fn doca_devinfo_list_create(
        dev_list: *mut *mut *mut doca_devinfo,
        nb_devs: *mut u32,
    ) -> doca_error_t;
}
extern "C" {
    #[doc = " @brief Destroy list of local device info structures.\n\n Destroys the list of device information, once the list has been destroyed, all elements become invalid.\n\n @param [in] dev_list\n List to be destroyed.\n\n @return\n DOCA_SUCCESS - in case of success.\n Error code - in case of failure:\n - DOCA_ERROR_INVALID_VALUE - received invalid input.\n - DOCA_ERROR_IN_USE - at least one device in the list is in a corrupted state."]
    pub fn doca_devinfo_list_destroy(dev_list: *mut *mut doca_devinfo) -> doca_error_t;
}
extern "C" {
    #[doc = " @brief Create list of available representor devices accessible by dev.\n\n Returns all representors managed by the provided device.\n The provided device must be a local device.\n The representor may represent a network function attached to the host,\n or it can represent an emulated function attached to the host.\n\n @param [in] dev\n Local device with access to representors.\n @param [in] filter\n Bitmap filter of representor types. See enum doca_dev_rep_filter for more details.\n @param [out] dev_list_rep\n Pointer to array of pointers. Output can then be accessed as follows (*dev_list_rep)[idx].\n @param [out] nb_devs_rep\n Number of available representor devices.\n\n @return\n DOCA_SUCCESS - in case of success.\n Error code - in case of failure:\n - DOCA_ERROR_INVALID_VALUE - received invalid input.\n - DOCA_ERROR_NO_MEMORY - failed to allocate memory for list.\n - DOCA_ERROR_NOT_SUPPORTED - local device does not expose representor devices.\n @note Returned list must be destroyed using doca_devinfo_rep_list_destroy()"]
    pub fn doca_devinfo_rep_list_create(
        dev: *mut doca_dev,
        filter: ::std::os::raw::c_int,
        dev_list_rep: *mut *mut *mut doca_devinfo_rep,
        nb_devs_rep: *mut u32,
    ) -> doca_error_t;
}
extern "C" {
    #[doc = " @brief Destroy list of representor device info structures.\n\n Destroy list of representor device information, once the list has been destroyed,\n all elements of the list are considered invalid.\n\n @param [in] dev_list_rep\n List to be destroyed.\n\n @return\n DOCA_SUCCESS - in case of success.\n Error code - in case of failure:\n - DOCA_ERROR_INVALID_VALUE - received invalid input.\n - DOCA_ERROR_IN_USE - the doca_dev that created the list is in a corrupted state."]
    pub fn doca_devinfo_rep_list_destroy(dev_list_rep: *mut *mut doca_devinfo_rep) -> doca_error_t;
}
extern "C" {
    #[doc = " @brief Initialize local device for use.\n\n @param [in] devinfo\n The devinfo structure of the requested device.\n @param [out] dev\n Initialized local doca device instance on success. Valid on success only.\n\n @return\n DOCA_SUCCESS - in case of success.\n Error code - in case of failure:\n - DOCA_ERROR_INVALID_VALUE - received invalid input.\n - DOCA_ERROR_NO_MEMORY - failed to allocate protection domain for device.\n - DOCA_ERROR_NOT_CONNECTED - failed to open device.\n @note In case the same device was previously opened, then the same doca_dev instance is returned."]
    pub fn doca_dev_open(devinfo: *mut doca_devinfo, dev: *mut *mut doca_dev) -> doca_error_t;
}
extern "C" {
    #[doc = " @brief Destroy allocated local device instance.\n\n @param [in] dev\n The local doca device instance.\n\n @return\n DOCA_SUCCESS - in case of success.\n - DOCA_ERROR_IN_USE - failed to deallocate device resources."]
    pub fn doca_dev_close(dev: *mut doca_dev) -> doca_error_t;
}
extern "C" {
    #[doc = " @brief Initialize representor device for use.\n\n @param [in] devinfo\n The devinfo structure of the requested device.\n @param [out] dev_rep\n Initialized representor doca device instance on success. Valid on success only.\n\n @return\n DOCA_SUCCESS - in case of success.\n Error code - in case of failure:\n - DOCA_ERROR_INVALID_VALUE - received invalid input.\n - DOCA_ERROR_NO_MEMORY - failed to allocate memory for device."]
    pub fn doca_dev_rep_open(
        devinfo: *mut doca_devinfo_rep,
        dev_rep: *mut *mut doca_dev_rep,
    ) -> doca_error_t;
}
extern "C" {
    #[doc = " @brief Destroy allocated representor device instance.\n\n @param [in] dev\n The representor doca device instance.\n\n @return\n DOCA_SUCCESS - in case of success.\n Error code - in case of failure:\n - DOCA_ERROR_INVALID_VALUE - received invalid input.\n - DOCA_ERROR_IN_USE - failed to deallocate device resources."]
    pub fn doca_dev_rep_close(dev: *mut doca_dev_rep) -> doca_error_t;
}
extern "C" {
    #[doc = " @brief Get local device info from device.\n This should be useful when wanting to query information about device after opening it,\n and destroying the devinfo list.\n\n @param [in] dev\n The doca device instance.\n\n @return\n The matching doca_devinfo instance in case of success, NULL in case dev is invalid."]
    pub fn doca_dev_as_devinfo(dev: *const doca_dev) -> *mut doca_devinfo;
}
extern "C" {
    #[doc = " @brief Get representor device info from device.\n This should be useful when wanting to query information about device after opening it,\n and destroying the devinfo list.\n\n @param [in] dev_rep\n The representor doca device instance.\n\n @return\n The matching doca_devinfo_rep instance in case of success, NULL in case dev_rep is invalid."]
    pub fn doca_dev_rep_as_devinfo(dev_rep: *mut doca_dev_rep) -> *mut doca_devinfo_rep;
}
extern "C" {
    #[doc = " @brief Get the PCI address of a DOCA devinfo.\n\n @details The BDF of the device - same as the address in lspci.\n The PCI address type: struct doca_pci_bdf.\n\n @param [in] devinfo\n The device to query.\n @param [out] pci_addr\n The PCI address of devinfo.\n\n @return\n DOCA_SUCCESS - in case of success.\n Error code - in case of failure:\n - DOCA_ERROR_INVALID_VALUE - received invalid input.\n - DOCA_ERROR_NOT_CONNECTED - provided devinfo does not support this property.\n - DOCA_ERROR_OPERATING_SYSTEM - failed to acquire the PCI address from the OS"]
    pub fn doca_devinfo_get_pci_addr(
        devinfo: *const doca_devinfo,
        pci_addr: *mut doca_pci_bdf,
    ) -> doca_error_t;
}
extern "C" {
    #[doc = " @brief Get the IPv4 address of a DOCA devinfo.\n\n @details The IPv4 address type: uint8_t[DOCA_DEVINFO_IPV4_ADDR_SIZE].\n\n @param [in] devinfo\n The device to query.\n @param [out] ipv4_addr\n The IPv4 address of devinfo.\n @param [in] size\n The size of the input ipv4_addr buffer, must be at least DOCA_DEVINFO_IPV4_ADDR_SIZE\n\n @return\n DOCA_SUCCESS - in case of success.\n Error code - in case of failure:\n - DOCA_ERROR_INVALID_VALUE - received invalid input.\n - DOCA_ERROR_OPERATING_SYSTEM - failed to acquire the IPv4 address from the OS"]
    pub fn doca_devinfo_get_ipv4_addr(
        devinfo: *const doca_devinfo,
        ipv4_addr: *mut u8,
        size: u32,
    ) -> doca_error_t;
}
extern "C" {
    #[doc = " @brief Get the IPv6 address of a DOCA devinfo.\n\n @details The IPv6 address type: uint8_t[DOCA_DEVINFO_IPV6_ADDR_SIZE].\n\n @param [in] devinfo\n The device to query.\n @param [out] ipv6_addr\n The IPv6 address of devinfo.\n @param [in] size\n The size of the input ipv6_addr buffer, must be at least DOCA_DEVINFO_IPV6_ADDR_SIZE\n\n @return\n DOCA_SUCCESS - in case of success.\n Error code - in case of failure:\n - DOCA_ERROR_INVALID_VALUE - received invalid input.\n - DOCA_ERROR_OPERATING_SYSTEM - failed to acquire the IPv6 address from the OS"]
    pub fn doca_devinfo_get_ipv6_addr(
        devinfo: *const doca_devinfo,
        ipv6_addr: *mut u8,
        size: u32,
    ) -> doca_error_t;
}
extern "C" {
    #[doc = " @brief Get the name of the ethernet interface of a DOCA devinfo.\n\n @details The name of the ethernet interface is the same as it's name in ifconfig.\n The name of the ethernet interface type: char[DOCA_DEVINFO_IFACE_NAME_SIZE].\n\n @param [in] devinfo\n The device to query.\n @param [out] iface_name\n The name of the ethernet interface of devinfo.\n @param [in] size\n The size of the input iface_name buffer, must be at least DOCA_DEVINFO_IFACE_NAME_SIZE\n which includes the null terminating byte.\n\n @return\n DOCA_SUCCESS - in case of success.\n Error code - in case of failure:\n - DOCA_ERROR_INVALID_VALUE - received invalid input.\n - DOCA_ERROR_OPERATING_SYSTEM - failed to acquire the interface name from the OS"]
    pub fn doca_devinfo_get_iface_name(
        devinfo: *const doca_devinfo,
        iface_name: *mut ::std::os::raw::c_char,
        size: u32,
    ) -> doca_error_t;
}
extern "C" {
    #[doc = " @brief Get the name of the IB device represented by a DOCA devinfo.\n\n @details The name of the IB device type: char[DOCA_DEVINFO_IBDEV_NAME_SIZE].\n\n @param [in] devinfo\n The device to query.\n @param [out] ibdev_name\n The name of the IB device represented by devinfo.\n @param [in] size\n The size of the input ibdev_name buffer, must be at least DOCA_DEVINFO_IBDEV_NAME_SIZE\n which includes the null terminating byte.\n\n @return\n DOCA_SUCCESS - in case of success.\n Error code - in case of failure:\n - DOCA_ERROR_INVALID_VALUE - received invalid input.\n - DOCA_ERROR_NO_MEMORY - no memory (exception thrown)."]
    pub fn doca_devinfo_get_ibdev_name(
        devinfo: *const doca_devinfo,
        ibdev_name: *mut ::std::os::raw::c_char,
        size: u32,
    ) -> doca_error_t;
}
extern "C" {
    #[doc = " @brief Get the hotplug manager capability of a DOCA devinfo.\n\n @details The hotplug manager property type: uint8_t*.\n\n @param [in] devinfo\n The device to query.\n @param [out] is_hotplug_manager\n 1 if the hotplug manager capability is supported, 0 otherwise.\n\n @return\n DOCA_SUCCESS - in case of success.\n Error code - in case of failure:\n - DOCA_ERROR_INVALID_VALUE - received invalid input.\n - DOCA_ERROR_DRIVER - failed to query capability support."]
    pub fn doca_devinfo_get_is_hotplug_manager_supported(
        devinfo: *const doca_devinfo,
        is_hotplug_manager: *mut u8,
    ) -> doca_error_t;
}
extern "C" {
    #[doc = " @brief Get the mmap export capability of the device.\n\n @details Get uint8_t value defining if the device can be used to export an mmap.\n See doca_mmap_export() in doca_mmap.h\n true  - device can be used with the mmap export API.\n false - export API is guaranteed to faile with DOCA_ERROR_NOT_SUPPORTED.\n\n @param [in] devinfo\n The device to query.\n @param [out] export\n 1 if the mmap export capability is supported, 0 otherwise.\n @return\n DOCA_SUCCESS - in case of success.\n Error code - in case of failure:\n - DOCA_ERROR_INVALID_VALUE - received invalid input.\n - DOCA_ERROR_DRIVER - failed to query capability support."]
    pub fn doca_devinfo_get_is_mmap_export_supported(
        devinfo: *const doca_devinfo,
        mmap_export: *mut u8,
    ) -> doca_error_t;
}
extern "C" {
    #[doc = " @brief Get the mmap create from export capability of the device.\n\n @details Get uint8_t value defining if the device can be used to create an mmap from an exported mmap.\n See doca_mmap_create_from_export() in doca_mmap.h\n true  - device can be used with the mmap create from export API.\n false - create from export API is guaranteed to fail with DOCA_ERROR_NOT_SUPPORTED.\n\n @param [in] devinfo\n The device to query.\n @param [out] from_export\n 1 if the mmap from export capability is supported, 0 otherwise.\n\n @return\n DOCA_SUCCESS - in case of success.\n Error code - in case of failure:\n - DOCA_ERROR_INVALID_VALUE - received invalid input.\n - DOCA_ERROR_DRIVER - failed to query capability support."]
    pub fn doca_devinfo_get_is_mmap_from_export_supported(
        devinfo: *const doca_devinfo,
        from_export: *mut u8,
    ) -> doca_error_t;
}
extern "C" {
    #[doc = " @brief Get the representor devices discovery capability of the device.\n\n @details Get uint8_t value defining if the device can be used to create list of representor devices.\n In case true is returned, then this device supports at least one representor type.\n See doca_devinfo_rep_list_create().\n true  - device can be used with the remote list create API with filter DOCA_DEV_REP_FILTER_ALL.\n false - providing DOCA_DEV_REP_FILTER_ALL is guaranteed to fail with DOCA_ERROR_NOT_SUPPORTED.\n\n @param [in] devinfo\n The device to query.\n @param [out] all_supported\n 1 if the rep list all capability is supported, 0 otherwise.\n\n @return\n DOCA_SUCCESS - in case of success.\n Error code - in case of failure:\n - DOCA_ERROR_INVALID_VALUE - received invalid input.\n - DOCA_ERROR_DRIVER - failed to query capability support."]
    pub fn doca_devinfo_rep_get_is_list_all_supported(
        devinfo: *const doca_devinfo,
        all_supported: *mut u8,
    ) -> doca_error_t;
}
extern "C" {
    #[doc = " @brief Get the remote net discovery capability of the device.\n\n @details Get uint8_t value defining if the device can be used to create list of net remote devices.\n See doca_devinfo_remote_list_create().\n true  - device can be used with the remote list create API with filter DOCA_DEV_REMOTE_FILTER_NET.\n false - providing DOCA_DEV_REMOTE_FILTER_NET is guaranteed to fail with DOCA_ERROR_NOT_SUPPORTED.\n\n @param [in] devinfo\n The device to query.\n @param [out] net_supported\n 1 if the rep list net capability is supported, 0 otherwise.\n\n @return\n DOCA_SUCCESS - in case of success.\n Error code - in case of failure:\n - DOCA_ERROR_INVALID_VALUE - received invalid input.\n - DOCA_ERROR_DRIVER - failed to query capability support."]
    pub fn doca_devinfo_rep_get_is_list_net_supported(
        devinfo: *const doca_devinfo,
        net_supported: *mut u8,
    ) -> doca_error_t;
}
extern "C" {
    #[doc = " @brief Get the remote virtio fs discovery capability of the device.\n\n @details Get uint8_t value defining if the device can be used to create list of virtio fs remote devices.\n See doca_devinfo_remote_list_create().\n true  - device can be used with the remote list create API with filter DOCA_DEV_REMOTE_FILTER_VIRTIO_FS.\n false - providing DOCA_DEV_REMOTE_FILTER_VIRTIO_FS is guaranteed to fail with DOCA_ERROR_NOT_SUPPORTED.\n\n @param [in] devinfo\n The device to query.\n @param [out] virtio_fs_supported\n 1 if the list virtio fs capability is supported, 0 otherwise.\n\n @return\n DOCA_SUCCESS - in case of success.\n Error code - in case of failure:\n - DOCA_ERROR_INVALID_VALUE - received invalid input.\n - DOCA_ERROR_DRIVER - failed to query capability support."]
    pub fn doca_devinfo_rep_get_is_list_virtio_fs_supported(
        devinfo: *const doca_devinfo,
        virtio_fs_supported: *mut u8,
    ) -> doca_error_t;
}
extern "C" {
    #[doc = " @brief Get the remote virtio net discovery capability of the device.\n\n @details Get uint8_t value defining if the device can be used to create list of virtio net remote devices.\n See doca_devinfo_remote_list_create().\n true  - device can be used with the remote list create API with filter DOCA_DEV_REMOTE_FILTER_VIRTIO_NET.\n false - providing DOCA_DEV_REMOTE_FILTER_VIRTIO_NET is guaranteed to fail with DOCA_ERROR_NOT_SUPPORTED.\n\n @param [in] devinfo\n The device to query.\n @param [out] virtio_net_supported\n 1 if the list virtio net capability is supported, 0 otherwise.\n\n @return\n DOCA_SUCCESS - in case of success.\n Error code - in case of failure:\n - DOCA_ERROR_INVALID_VALUE - received invalid input.\n - DOCA_ERROR_DRIVER - failed to query capability support."]
    pub fn doca_devinfo_rep_get_is_list_virtio_net_supported(
        devinfo: *const doca_devinfo,
        virtio_net_supported: *mut u8,
    ) -> doca_error_t;
}
extern "C" {
    #[doc = " @brief Get the remote virtio blk discovery capability of the device.\n\n @details Get uint8_t value defining if the device can be used to create list of virtio blk remote devices.\n See doca_devinfo_remote_list_create().\n true  - device can be used with the remote list create API with filter DOCA_DEV_REMOTE_FILTER_VIRTIO_BLK.\n false - providing DOCA_DEV_REMOTE_FILTER_VIRTIO_BLK is guaranteed to fail with DOCA_ERROR_NOT_SUPPORTED.\n\n @param [in] devinfo\n The device to query.\n @param [out] virtio_blk_supported\n 1 if the list virtio blk capability is supported, 0 otherwise.\n\n @return\n DOCA_SUCCESS - in case of success.\n Error code - in case of failure:\n - DOCA_ERROR_INVALID_VALUE - received invalid input.\n - DOCA_ERROR_DRIVER - failed to query capability support."]
    pub fn doca_devinfo_rep_get_is_list_virtio_blk_supported(
        devinfo: *const doca_devinfo,
        virtio_blk_supported: *mut u8,
    ) -> doca_error_t;
}
extern "C" {
    #[doc = " @brief Get the remote nvme discovery capability of the device.\n\n @details Get uint8_t value defining if the device can be used to create list of nvme remote devices.\n See doca_devinfo_remote_list_create().\n true  - device can be used with the remote list create API with filter DOCA_DEV_REMOTE_FILTER_NVME.\n false - providing DOCA_DEV_REMOTE_FILTER_NVME is guaranteed to fail with DOCA_ERROR_NOT_SUPPORTED.\n\n @param [in] devinfo\n The device to query.\n @param [out] nvme_supported\n 1 if the list nvme capability is supported, 0 otherwise.\n\n @return\n DOCA_SUCCESS - in case of success.\n Error code - in case of failure:\n - DOCA_ERROR_INVALID_VALUE - received invalid input.\n - DOCA_ERROR_DRIVER - failed to query capability support."]
    pub fn doca_devinfo_rep_get_is_list_nvme_supported(
        devinfo: *const doca_devinfo,
        nvme_supported: *mut u8,
    ) -> doca_error_t;
}
extern "C" {
    #[doc = " @brief Get the Vendor Unique ID of a representor DOCA devinfo.\n\n @details The Vendor Unique ID is used as stable ID of a VF/PF.\n The Vendor Unique ID type: char[DOCA_DEVINFO_VUID_SIZE].\n\n @param [in] devinfo_rep\n The representor device to query.\n @param [out] rep_vuid\n The Vendor Unique ID of devinfo_rep.\n @param [in] size\n The size of the vuid buffer, including the terminating null byte ('\\0').\n\n @return\n DOCA_SUCCESS - in case of success.\n Error code - in case of failure:\n - DOCA_ERROR_INVALID_VALUE - received invalid input."]
    pub fn doca_devinfo_rep_get_vuid(
        devinfo_rep: *const doca_devinfo_rep,
        rep_vuid: *mut ::std::os::raw::c_char,
        size: u32,
    ) -> doca_error_t;
}
extern "C" {
    #[doc = " @brief Get the PCI address of a DOCA devinfo_rep.\n\n @details The PCI address type: struct doca_pci_bdf.\n\n @param [in] devinfo_rep\n The representor of device to query.\n @param [out] pci_addr\n The PCI address of the devinfo_rep.\n\n @return\n DOCA_SUCCESS - in case of success.\n Error code - in case of failure:\n - DOCA_ERROR_INVALID_VALUE - received invalid input."]
    pub fn doca_devinfo_rep_get_pci_addr(
        devinfo_rep: *const doca_devinfo_rep,
        pci_addr: *mut doca_pci_bdf,
    ) -> doca_error_t;
}
extern "C" {
    #[doc = " @brief Get the PCI function type of a DOCA devinfo_rep.\n\n @details The pci function type: enum doca_pci_func_type.\n\n @param [in] devinfo_rep\n The representor of device to query.\n @param [out] pci_func_type\n The PCI function type of the devinfo_rep.\n\n @return\n DOCA_SUCCESS - in case of success.\n Error code - in case of failure:\n - DOCA_ERROR_INVALID_VALUE - received invalid input."]
    pub fn doca_devinfo_rep_get_pci_func_type(
        devinfo_rep: *const doca_devinfo_rep,
        pci_func_type: *mut doca_pci_func_type,
    ) -> doca_error_t;
}
pub const doca_comm_channel_msg_flags_DOCA_CC_MSG_FLAG_NONE: doca_comm_channel_msg_flags = 0;
#[doc = " @brief Flags for send/receive functions"]
pub type doca_comm_channel_msg_flags = ::std::os::raw::c_uint;
#[doc = " @brief Handle for local endpoint"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct doca_comm_channel_ep_t {
    _unused: [u8; 0],
}
#[doc = " @brief Handle for peer address"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct doca_comm_channel_addr_t {
    _unused: [u8; 0],
}
extern "C" {
    #[doc = " DOCA comm_channel Configuration Attributes\n/\n/**\n @brief Get the comm_channel maximum Service name length.\n\n @param [out] max_service_name_len\n The comm_channel max service name length, including the terminating null byte ('\\0').\n @return\n DOCA_SUCCESS on success.\n DOCA_ERROR_INVALID_VALUE if max_service_name_len is NULL."]
    pub fn doca_comm_channel_get_max_service_name_len(
        max_service_name_len: *mut u32,
    ) -> doca_error_t;
}
extern "C" {
    #[doc = " @brief Get the maximum message size supported by comm_channel.\n @param [in] devinfo\n devinfo that should be inquired for its maximum message size under comm channel limitations.\n @param [out] max_message_size\n the maximum message size supported by comm_channel.\n @return\n DOCA_SUCCESS on success.\n DOCA_ERROR_INVALID_VALUE if either devinfo or max_message_size is NULL.\n DOCA_ERROR_UNEXPECTED if an unexpected error occurred."]
    pub fn doca_comm_channel_get_max_message_size(
        devinfo: *mut doca_devinfo,
        max_message_size: *mut u32,
    ) -> doca_error_t;
}
extern "C" {
    #[doc = " @brief Get the maximum send queue size supported by comm_channel.\n @param [in] devinfo\n devinfo that should be inquired for its maximum send queue size under comm channel limitations.\n @param [out] max_send_queue_size\n the maximum send queue size supported by comm_channel.\n @return\n DOCA_SUCCESS on success.\n DOCA_ERROR_INVALID_VALUE if either devinfo or max_send_queue_size is NULL.\n DOCA_ERROR_UNEXPECTED if an unexpected error occurred."]
    pub fn doca_comm_channel_get_max_send_queue_size(
        devinfo: *mut doca_devinfo,
        max_send_queue_size: *mut u32,
    ) -> doca_error_t;
}
extern "C" {
    #[doc = " @brief Get the maximum receive queue size supported by comm_channel.\n @param [in] devinfo\n devinfo that should be inquired for its maximum receive queue size under comm channel limitations.\n @param [out] max_recv_queue_size\n the maximum receive queue size supported by comm_channel.\n @return\n DOCA_SUCCESS on success.\n DOCA_ERROR_INVALID_VALUE if either devinfo or max_recv_queue_size is NULL.\n DOCA_ERROR_UNEXPECTED if an unexpected error occurred."]
    pub fn doca_comm_channel_get_max_recv_queue_size(
        devinfo: *mut doca_devinfo,
        max_recv_queue_size: *mut u32,
    ) -> doca_error_t;
}
extern "C" {
    #[doc = " @brief Get the maximum number of connections the service can hold.\n @note This capability should be queried only on the service side.\n @param [in] devinfo\n devinfo that should be inquired for its maximum number of connections.\n @param [out] max_num_connections\n the maximum number of connections the service can hold.\n @return\n DOCA_SUCCESS on success.\n DOCA_ERROR_INVALID_VALUE if either devinfo or max_num_connections is NULL.\n DOCA_ERROR_NOT_SUPPORTED if querying this capability is not supported by the device.\n DOCA_ERROR_UNEXPECTED if an unexpected error occurred."]
    pub fn doca_comm_channel_get_service_max_num_connections(
        devinfo: *mut doca_devinfo,
        max_num_connections: *mut u32,
    ) -> doca_error_t;
}
extern "C" {
    #[doc = " @brief Create local endpoint\n The endpoint handle represents all the configuration needed for the channel to run.\n The user needs to hold one endpoint for all actions with the comm channel on his side\n @param [out] ep\n handle to the newly created endpoint.\n @return\n DOCA_SUCCESS on success.\n DOCA_ERROR_INVALID_VALUE if no ep pointer or no attribute object was given.\n DOCA_ERROR_NO_MEMORY if memory allocation failed during ep creation.\n DOCA_ERROR_INITIALIZATION if initialization of ep failed.\n DOCA_ERROR_DRIVER if acquiring device attributes failed."]
    pub fn doca_comm_channel_ep_create(ep: *mut *mut doca_comm_channel_ep_t) -> doca_error_t;
}
extern "C" {
    #[doc = " @brief get device property of endpoint.\n @param [in] ep\n endpoint from which the property should be retrieved.\n @param [out] device\n current device used in endpoint.\n @return\n DOCA_SUCCESS if property was returned successfully.\n DOCA_ERROR_INVALID_VALUE if an invalid parameter was given."]
    pub fn doca_comm_channel_ep_get_device(
        ep: *mut doca_comm_channel_ep_t,
        device: *mut *mut doca_dev,
    ) -> doca_error_t;
}
extern "C" {
    #[doc = " @brief get device representor property of endpoint.\n @param [in] ep\n endpoint from which the property should be retrieved.\n @param [out] device_rep\n current device representor used in endpoint.\n @return\n DOCA_SUCCESS if property returned successfully.\n DOCA_ERROR_INVALID_VALUE if an invalid parameter was given."]
    pub fn doca_comm_channel_ep_get_device_rep(
        ep: *mut doca_comm_channel_ep_t,
        device_rep: *mut *mut doca_dev_rep,
    ) -> doca_error_t;
}
extern "C" {
    #[doc = " @brief get maximal msg size property of endpoint.\n The size returned is the actual size being used and might differ from the size set with\n doca_comm_channel_ep_set_max_msg_size(), as there is a minimal size requirement.\n If maximal msg size was not set, using doca_comm_channel_ep_set_max_msg_size(), a default value is used and can be\n inquired by calling doca_comm_channel_ep_get_max_msg_size().\n @param [in] ep\n endpoint from which the property should be retrieved.\n @param [out] max_msg_size\n maximal msg size used by the endpoint.\n @return\n DOCA_SUCCESS if property was returned successfully.\n DOCA_ERROR_INVALID_VALUE if an invalid parameter was given."]
    pub fn doca_comm_channel_ep_get_max_msg_size(
        ep: *mut doca_comm_channel_ep_t,
        max_msg_size: *mut u16,
    ) -> doca_error_t;
}
extern "C" {
    #[doc = " @brief get send queue size property of endpoint.\n The size returned is the actual size being used and might differ from the size set with\n doca_comm_channel_ep_set_send_queue_size(), as there is a minimal size requirement and the size is rounded up to the\n closest power of 2.\n If send queue size was not set, using doca_comm_channel_ep_set_send_queue_size(), a default value is used and can be\n inquired by calling doca_comm_channel_ep_get_send_queue_size().\n @param [in] ep\n endpoint from which the property should be retrieved.\n @param [out] send_queue_size\n send queue size used by the endpoint.\n @return\n DOCA_SUCCESS if property was returned successfully.\n DOCA_ERROR_INVALID_VALUE if an invalid parameter was given."]
    pub fn doca_comm_channel_ep_get_send_queue_size(
        ep: *mut doca_comm_channel_ep_t,
        send_queue_size: *mut u16,
    ) -> doca_error_t;
}
extern "C" {
    #[doc = " @brief get receive queue size property of endpoint.\n The size returned is the actual size being used and might differ from the size set with\n doca_comm_channel_ep_set_recv_queue_size(), as there is a minimal size requirement and the size is rounded up to the\n closest power of 2.\n If receive queue size was not set, using doca_comm_channel_ep_set_recv_queue_size(), a default value is used and can\n be inquired by calling doca_comm_channel_ep_get_recv_queue_size().\n @param [in] ep\n endpoint from which the property should be retrieved.\n @param [out] recv_queue_size\n receive queue size used by the endpoint.\n @return\n DOCA_SUCCESS if property was returned successfully.\n DOCA_ERROR_INVALID_VALUE if an invalid parameter was given."]
    pub fn doca_comm_channel_ep_get_recv_queue_size(
        ep: *mut doca_comm_channel_ep_t,
        recv_queue_size: *mut u16,
    ) -> doca_error_t;
}
extern "C" {
    #[doc = " @brief set device property for endpoint.\n @param [in] ep\n endpoint to set the property for.\n @param [in] device\n device to use in endpoint.\n @return\n DOCA_SUCCESS if property set successfully.\n DOCA_ERROR_INVALID_VALUE if an invalid parameter was given.\n DOCA_ERROR_BAD_STATE if endpoint is already active."]
    pub fn doca_comm_channel_ep_set_device(
        ep: *mut doca_comm_channel_ep_t,
        device: *mut doca_dev,
    ) -> doca_error_t;
}
extern "C" {
    #[doc = " @brief set device representor property for endpoint.\n @param [in] ep\n endpoint to set the property for.\n @param [in] device_rep\n device representor to use in endpoint.\n @return\n DOCA_SUCCESS if property set successfully.\n DOCA_ERROR_INVALID_VALUE if an invalid parameter was given.\n DOCA_ERROR_BAD_STATE if endpoint is already active."]
    pub fn doca_comm_channel_ep_set_device_rep(
        ep: *mut doca_comm_channel_ep_t,
        device_rep: *mut doca_dev_rep,
    ) -> doca_error_t;
}
extern "C" {
    #[doc = " @brief set maximal msg size property for endpoint.\n The value max_msg_size may be increased internally, the actual value can be queried using\n doca_comm_channel_ep_get_max_msg_size().\n @param [in] ep\n endpoint to set the property for.\n @param [in] max_msg_size\n maximal msg size to use in endpoint.\n @return\n DOCA_SUCCESS if property set successfully.\n DOCA_ERROR_INVALID_VALUE if an invalid parameter was given.\n DOCA_ERROR_BAD_STATE if endpoint is already active."]
    pub fn doca_comm_channel_ep_set_max_msg_size(
        ep: *mut doca_comm_channel_ep_t,
        max_msg_size: u16,
    ) -> doca_error_t;
}
extern "C" {
    #[doc = " @brief set send queue size property for endpoint.\n The value send_queue_size may be increased internally, the actual value can be queried using\n doca_comm_channel_ep_get_send_queue_size().\n @param [in] ep\n endpoint to set the property for.\n @param [in] send_queue_size\n send queue size to use in endpoint.\n @return\n DOCA_SUCCESS if property set successfully.\n DOCA_ERROR_INVALID_VALUE if an invalid parameter was given.\n DOCA_ERROR_BAD_STATE if endpoint is already active."]
    pub fn doca_comm_channel_ep_set_send_queue_size(
        ep: *mut doca_comm_channel_ep_t,
        send_queue_size: u16,
    ) -> doca_error_t;
}
extern "C" {
    #[doc = " @brief set receive queue size property for endpoint.\n The value recv_queue_size may be increased internally, the actual value can be queried using\n doca_comm_channel_ep_get_recv_queue_size().\n @param [in] ep\n endpoint to set the property for.\n @param [in] recv_queue_size\n receive queue size to use in endpoint.\n @return\n DOCA_SUCCESS if property set successfully.\n DOCA_ERROR_INVALID_VALUE if an invalid parameter was given.\n DOCA_ERROR_BAD_STATE if endpoint is already active."]
    pub fn doca_comm_channel_ep_set_recv_queue_size(
        ep: *mut doca_comm_channel_ep_t,
        recv_queue_size: u16,
    ) -> doca_error_t;
}
pub type doca_event_channel_t = ::std::os::raw::c_int;
extern "C" {
    #[doc = " @brief Extract the event_channel handles for user's use\n When the user send/receive packets with non-blocking mode, this handle can be used to get interrupt when a new\n event happened, using epoll() or similar function.\n The event channels are owned by the endpoint and release when calling @ref doca_comm_channel_ep_destroy().\n This function can be called only after calling doca_comm_channel_ep_listen() or doca_comm_channel_ep_connect().\n\n @param [in] local_ep\n handle for the endpoint created beforehand with doca_comm_channel_ep_create().\n @param [out] send_event_channel\n handle for send event channel.\n @param [out] recv_event_channel\n handle for receive event channel.\n @return\n DOCA_SUCCESS on success\n DOCA_ERROR_INVALID_VALUE if no ep was provided or if both event channel output params are null.\n DOCA_ERROR_BAD_STATE if called before calling doca_comm_channel_ep_listen() or doca_comm_channel_ep_connect().\n DOCA_ERROR_NOT_FOUND if another error occurred."]
    pub fn doca_comm_channel_ep_get_event_channel(
        local_ep: *mut doca_comm_channel_ep_t,
        send_event_channel: *mut doca_event_channel_t,
        recv_event_channel: *mut doca_event_channel_t,
    ) -> doca_error_t;
}
extern "C" {
    #[doc = " @brief Arm the event_channel handle for transmitted messages.\n This function arms the transmit completion queue, facilitating blocking on the transmit event channel.\n Blocking should be implemented by the user (poll in Linux, GetQueuedCompletionStatus in Windows).\n\n @param [in] local_ep\n handle for the endpoint created beforehand with doca_comm_channel_ep_create().\n @return\n DOCA_SUCCESS on success\n DOCA_ERROR_INVALID_VALUE if no ep object was given."]
    pub fn doca_comm_channel_ep_event_handle_arm_send(
        local_ep: *mut doca_comm_channel_ep_t,
    ) -> doca_error_t;
}
extern "C" {
    #[doc = " @brief Arm the event_channel handle for received messages.\n This function arms the receive completion queue, facilitating blocking on the receive event channel.\n Blocking should be implemented by the user (poll in Linux, GetQueuedCompletionStatus in Windows).\n\n @param [in] local_ep\n handle for the endpoint created beforehand with doca_comm_channel_ep_create().\n @return\n DOCA_SUCCESS on success\n DOCA_ERROR_INVALID_VALUE if no ep object was given."]
    pub fn doca_comm_channel_ep_event_handle_arm_recv(
        local_ep: *mut doca_comm_channel_ep_t,
    ) -> doca_error_t;
}
extern "C" {
    #[doc = " @brief Service side listen on all interfaces.\n\n The function opens new QP for each vhca_id (gvmi) it exposes to and wait for new connections.\n After calling this function the user should call doca_comm_channel_ep_recvfrom() in order to get\n new peers to communicate with.\n\n This function available only for service side use.\n\n @param [in] local_ep\n handle for the endpoint created beforehand with doca_comm_channel_ep_create().\n @param [in] name\n identifies the service. Use doca_comm_channel_get_max_service_name_len() to get the maximal service name length.\n @return\n DOCA_SUCCESS on success\n DOCA_ERROR_INVALID_VALUE if no ep object or no name was given.\n DOCA_ERROR_BAD_STATE if no doca_dev or no doca_dev_rep was set.\n DOCA_ERROR_NOT_PERMITTED if the function was called on the client side or the endpoint is already listening.\n DOCA_ERROR_NO_MEMORY if memory allocation failed.\n DOCA_ERROR_INITIALIZATION if initialization of service failed.\n DOCA_ERROR_CONNECTION_ABORTED if registration of service failed.\n DOCA_ERROR_DRIVER if acquiring device attributes failed."]
    pub fn doca_comm_channel_ep_listen(
        local_ep: *mut doca_comm_channel_ep_t,
        name: *const ::std::os::raw::c_char,
    ) -> doca_error_t;
}
extern "C" {
    #[doc = " @brief Client side Connect\n\n This function available only for client-side use.\n As part of the connection process, the client send a \"hello\" message to the service to inform\n him about new connection.\n\n If the connect function is being called before the service perform listen with the same name\n the connection will fail.\n\n @param [in] local_ep\n handle for the endpoint created beforehand with doca_comm_channel_ep_create().\n @param [in] name\n identifies the service. Use doca_comm_channel_get_max_service_name_len() to get the maximal service name length.\n @param [out] peer_addr\n handle to use for sending packets and recognize source of messages.\n @return\n DOCA_SUCCESS on success.\n DOCA_ERROR_INVALID_VALUE if no ep object, name or peer_address pointer given.\n DOCA_ERROR_NOT_PERMITTED if the function was called on the service or the endpoint is already connected.\n DOCA_ERROR_BAD_STATE if no doca_dev was set.\n DOCA_ERROR_NO_MEMORY if memory allocation failed.\n DOCA_ERROR_INITIALIZATION if initialization of ep connection failed.\n DOCA_ERROR_CONNECTION_ABORTED if connection failed for any reason (connections rejected or failed).\n DOCA_ERROR_DRIVER if acquiring device attributes failed."]
    pub fn doca_comm_channel_ep_connect(
        local_ep: *mut doca_comm_channel_ep_t,
        name: *const ::std::os::raw::c_char,
        peer_addr: *mut *mut doca_comm_channel_addr_t,
    ) -> doca_error_t;
}
extern "C" {
    #[doc = " @brief Send message to peer address.\n The connection to the wanted peer_address need to be established before sending the message.\n\n @param [in] local_ep\n handle for the endpoint created beforehand with doca_comm_channel_ep_create().\n @param [in] msg\n pointer to the message to be sent.\n @param [in] len\n length in bytes of msg.\n @param [in] flags\n flag for send command. currently no flags are supported.\n @param [in] peer_addr\n destination address handle of the send operation.\n @return\n DOCA_SUCCESS on success.\n DOCA_ERROR_NOT_CONNECTED if no peer_address was supplied or no connection was found.\n DOCA_ERROR_INVALID_VALUE if the supplied len was larger than the msgsize given at ep creation or any of the input\n                          variables are null.\n DOCA_ERROR_AGAIN if the send queue is full.\n \t\t    when returned, the user can use the endpoint's doca_event_channel_t to get indication for a new\n \t\t    empty slot.\n DOCA_ERROR_CONNECTION_RESET if the provided peer_addr experienced an error and it needs to be disconnected.\n DOCA_ERROR_INITIALIZATION if initialization of the DCI after a send error failed\n DOCA_ERROR_UNKNOWN if an unknown error occurred."]
    pub fn doca_comm_channel_ep_sendto(
        local_ep: *mut doca_comm_channel_ep_t,
        msg: *const ::std::os::raw::c_void,
        len: usize,
        flags: ::std::os::raw::c_int,
        peer_addr: *mut doca_comm_channel_addr_t,
    ) -> doca_error_t;
}
extern "C" {
    #[doc = " @brief Receive message from connected client/service.\n\n On service side, doca_comm_channel_ep_recvfrom() also used for accepting new connection from clients.\n\n @param [in] local_ep\n handle for the endpoint created beforehand with doca_comm_channel_ep_create().\n @param [in] msg\n pointer to the buffer where the message should be stored.\n @param [inout] len\n input - maximum len of bytes in the msg buffer, output - len of actual received message.\n @param [in] flags\n flag for receive command. currently no flags are supported.\n @param [out] peer_addr\n received message source address handle\n @return\n DOCA_SUCCESS on successful receive. If a message was received, the value pointed by len will be updated with\n the number of bytes received.\n DOCA_ERROR_INVALID_VALUE if any of the parameters is NULL.\n DOCA_ERROR_NOT_CONNECTED if endpoint is service and listen was not called.\n DOCA_ERROR_AGAIN if no message was received.\n \t\t    when returned, the user can use the endpoint's doca_event_channel_t to get indication for a new\n \t\t    arrival message.\n DOCA_ERROR_CONNECTION_RESET if the message received is from a peer_addr that has error.\n DOCA_ERROR_INITIALIZATION if initialization of the DCI after a send error failed\n DOCA_ERROR_UNKNOWN if an unknown error occurred."]
    pub fn doca_comm_channel_ep_recvfrom(
        local_ep: *mut doca_comm_channel_ep_t,
        msg: *mut ::std::os::raw::c_void,
        len: *mut usize,
        flags: ::std::os::raw::c_int,
        peer_addr: *mut *mut doca_comm_channel_addr_t,
    ) -> doca_error_t;
}
extern "C" {
    #[doc = " @brief Disconnect the endpoint from the remote peer.\n block until all resources related to peer address are freed\n new connection could be created on the endpoint\n @param [in] local_ep\n handle for the endpoint created beforehand with doca_comm_channel_ep_create().\n @param [in] peer_addr\n peer address to be disconnect from.\n @return\n DOCA_SUCCESS on success.\n DOCA_ERROR_INVALID_VALUE if no ep was provided.\n DOCA_ERROR_NOT_CONNECTED if there is no connection."]
    pub fn doca_comm_channel_ep_disconnect(
        local_ep: *mut doca_comm_channel_ep_t,
        peer_addr: *mut doca_comm_channel_addr_t,
    ) -> doca_error_t;
}
extern "C" {
    #[doc = " @brief Release endpoint handle.\n\n Blocking until all queued messages are sent\n The function close the event_channel and release all internal resources.\n The doca_comm_channel_ep_disconnect() is included as part of the destroy process.\n\n @param [in] local_ep\n handle for the endpoint created beforehand with doca_comm_channel_ep_create().\n @return\n DOCA_SUCCESS on success.\n DOCA_ERROR_NOT_CONNECTED if ep does not exist."]
    pub fn doca_comm_channel_ep_destroy(local_ep: *mut doca_comm_channel_ep_t) -> doca_error_t;
}
extern "C" {
    #[doc = " @brief Extract 'user_context' from peer_addr handle.\n By default, the 'user_context' is set to 0 and can be change using @ref doca_comm_channel_peer_addr_set_user_data()\n\n @param [in] peer_addr\n Pointer to peer_addr to extract user_context from.\n @param [out] user_data\n will contain the extracted data.\n\n @return\n DOCA_SUCCESS on success.\n DOCA_ERROR_INVALID_VALUE if peer_address or user_data is NULL."]
    pub fn doca_comm_channel_peer_addr_get_user_data(
        peer_addr: *mut doca_comm_channel_addr_t,
        user_data: *mut u64,
    ) -> doca_error_t;
}
extern "C" {
    #[doc = " @brief Save 'user_context' in peer_addr handle\n\n Can be use by the user to identify the peer address got from doca_comm_channel_ep_recvfrom().\n The user_context for new peers is initialized to 0.\n\n @param [in] peer_addr\n Pointer to peer_addr to set user_context to.\n @param [in] user_context\n Data to set for peer_addr.\n\n @return\n DOCA_SUCCESS on success.\n DOCA_ERROR_INVALID_VALUE if peer_address is NULL."]
    pub fn doca_comm_channel_peer_addr_set_user_data(
        peer_addr: *mut doca_comm_channel_addr_t,
        user_context: u64,
    ) -> doca_error_t;
}
extern "C" {
    #[doc = " @brief update statistics for given peer_addr\n\n Should be used before calling to any peer_addr information function to update the saved statistics.\n This function can also be used to check if connection to a given peer_addr is currently connected.\n If a connection has failed, it is the user's responsibility to call doca_comm_channel_ep_disconnect() to free the peer_addr resources.\n\n @param [in] peer_addr\n Pointer to peer_addr to update statistics in.\n\n @return\n DOCA_SUCCESS on success.\n DOCA_ERROR_INVALID_VALUE if peer_addr is NULL.\n DOCA_ERROR_CONNECTION_INPROGRESS if connection is not yet established.\n DOCA_ERROR_CONNECTION_ABORTED if the connection failed."]
    pub fn doca_comm_channel_peer_addr_update_info(
        peer_addr: *mut doca_comm_channel_addr_t,
    ) -> doca_error_t;
}
extern "C" {
    #[doc = " @brief get total messages sent to specific peer address\n\n This function will return the total number of messages sent to a given peer_addr, updated to the last time\n doca_comm_channel_peer_addr_update_info() was called.\n\n @param [in] peer_addr\n Pointer to peer_addr to query statistics for.\n @param [out] send_messages\n Will contain the number of sent messages to the given peer_addr.\n\n @return\n DOCA_SUCCESS on success.\n DOCA_ERROR_INVALID_VALUE if any of the arguments are NULL."]
    pub fn doca_comm_channel_peer_addr_get_send_messages(
        peer_addr: *const doca_comm_channel_addr_t,
        send_messages: *mut u64,
    ) -> doca_error_t;
}
extern "C" {
    #[doc = " @brief get total bytes sent to specific peer address\n\n This function will return the total number of bytes sent to a given peer_addr, updated to the last time\n doca_comm_channel_peer_addr_update_info() was called.\n\n @param [in] peer_addr\n Pointer to peer_addr to query statistics for.\n @param [out] send_bytes\n Will contain the number of sent messages to the given peer_addr.\n\n @return\n DOCA_SUCCESS on success.\n DOCA_ERROR_INVALID_VALUE if any of the arguments are NULL."]
    pub fn doca_comm_channel_peer_addr_get_send_bytes(
        peer_addr: *const doca_comm_channel_addr_t,
        send_bytes: *mut u64,
    ) -> doca_error_t;
}
extern "C" {
    #[doc = " @brief get total messages received from specific peer address\n\n This function will return the total number of messages received from a given peer_addr, updated to the last time\n doca_comm_channel_peer_addr_update_info() was called.\n\n @param [in] peer_addr\n Pointer to peer_addr to query statistics for.\n @param [out] recv_messages\n Will contain the number of received messages from the given peer_addr.\n\n @return\n DOCA_SUCCESS on success.\n DOCA_ERROR_INVALID_VALUE if any of the arguments are NULL."]
    pub fn doca_comm_channel_peer_addr_get_recv_messages(
        peer_addr: *const doca_comm_channel_addr_t,
        recv_messages: *mut u64,
    ) -> doca_error_t;
}
extern "C" {
    #[doc = " @brief get total bytes received from specific peer address\n\n This function will return the total number of bytes received from a given peer_addr, updated to the last time\n doca_comm_channel_peer_addr_update_info() was called.\n\n @param [in] peer_addr\n Pointer to peer_addr to query statistics for.\n @param [out] recv_bytes\n Will contain the number of received bytes from the given peer_addr.\n\n @return\n DOCA_SUCCESS on success.\n DOCA_ERROR_INVALID_VALUE if any of the arguments are NULL."]
    pub fn doca_comm_channel_peer_addr_get_recv_bytes(
        peer_addr: *const doca_comm_channel_addr_t,
        recv_bytes: *mut u64,
    ) -> doca_error_t;
}
extern "C" {
    #[doc = " @brief get number of messages in transmission to a specific peer address\n\n This function will return the number of messages still in transmission to a specific peer_addr, updated to the last time\n doca_comm_channel_peer_addr_update_info() was called.\n This function can be used to make sure all transmissions are finished before disconnection.\n\n @param [in] peer_addr\n Pointer to peer_addr to query statistics for.\n @param [out] send_in_flight_messages\n Will contain the number of sent messages in transmission to the given peer_addr.\n\n @return\n DOCA_SUCCESS on success.\n DOCA_ERROR_INVALID_VALUE if any of the arguments are NULL."]
    pub fn doca_comm_channel_peer_addr_get_send_in_flight_messages(
        peer_addr: *const doca_comm_channel_addr_t,
        send_in_flight_messages: *mut u64,
    ) -> doca_error_t;
}
pub type va_list = __builtin_va_list;
pub type __gnuc_va_list = __builtin_va_list;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct __mbstate_t {
    pub __count: ::std::os::raw::c_int,
    pub __value: __mbstate_t__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union __mbstate_t__bindgen_ty_1 {
    pub __wch: ::std::os::raw::c_uint,
    pub __wchb: [::std::os::raw::c_char; 4usize],
}
#[test]
fn bindgen_test_layout___mbstate_t__bindgen_ty_1() {
    const UNINIT: ::std::mem::MaybeUninit<__mbstate_t__bindgen_ty_1> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__mbstate_t__bindgen_ty_1>(),
        4usize,
        concat!("Size of: ", stringify!(__mbstate_t__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<__mbstate_t__bindgen_ty_1>(),
        4usize,
        concat!("Alignment of ", stringify!(__mbstate_t__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__wch) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__mbstate_t__bindgen_ty_1),
            "::",
            stringify!(__wch)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__wchb) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__mbstate_t__bindgen_ty_1),
            "::",
            stringify!(__wchb)
        )
    );
}
#[test]
fn bindgen_test_layout___mbstate_t() {
    const UNINIT: ::std::mem::MaybeUninit<__mbstate_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__mbstate_t>(),
        8usize,
        concat!("Size of: ", stringify!(__mbstate_t))
    );
    assert_eq!(
        ::std::mem::align_of::<__mbstate_t>(),
        4usize,
        concat!("Alignment of ", stringify!(__mbstate_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__count) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__mbstate_t),
            "::",
            stringify!(__count)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__value) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(__mbstate_t),
            "::",
            stringify!(__value)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _G_fpos_t {
    pub __pos: __off_t,
    pub __state: __mbstate_t,
}
#[test]
fn bindgen_test_layout__G_fpos_t() {
    const UNINIT: ::std::mem::MaybeUninit<_G_fpos_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_G_fpos_t>(),
        16usize,
        concat!("Size of: ", stringify!(_G_fpos_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_G_fpos_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_G_fpos_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__pos) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_G_fpos_t),
            "::",
            stringify!(__pos)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__state) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_G_fpos_t),
            "::",
            stringify!(__state)
        )
    );
}
pub type __fpos_t = _G_fpos_t;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _G_fpos64_t {
    pub __pos: __off64_t,
    pub __state: __mbstate_t,
}
#[test]
fn bindgen_test_layout__G_fpos64_t() {
    const UNINIT: ::std::mem::MaybeUninit<_G_fpos64_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_G_fpos64_t>(),
        16usize,
        concat!("Size of: ", stringify!(_G_fpos64_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_G_fpos64_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_G_fpos64_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__pos) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_G_fpos64_t),
            "::",
            stringify!(__pos)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__state) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_G_fpos64_t),
            "::",
            stringify!(__state)
        )
    );
}
pub type __fpos64_t = _G_fpos64_t;
pub type __FILE = _IO_FILE;
pub type FILE = _IO_FILE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_marker {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_codecvt {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_wide_data {
    _unused: [u8; 0],
}
pub type _IO_lock_t = ::std::os::raw::c_void;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_FILE {
    pub _flags: ::std::os::raw::c_int,
    pub _IO_read_ptr: *mut ::std::os::raw::c_char,
    pub _IO_read_end: *mut ::std::os::raw::c_char,
    pub _IO_read_base: *mut ::std::os::raw::c_char,
    pub _IO_write_base: *mut ::std::os::raw::c_char,
    pub _IO_write_ptr: *mut ::std::os::raw::c_char,
    pub _IO_write_end: *mut ::std::os::raw::c_char,
    pub _IO_buf_base: *mut ::std::os::raw::c_char,
    pub _IO_buf_end: *mut ::std::os::raw::c_char,
    pub _IO_save_base: *mut ::std::os::raw::c_char,
    pub _IO_backup_base: *mut ::std::os::raw::c_char,
    pub _IO_save_end: *mut ::std::os::raw::c_char,
    pub _markers: *mut _IO_marker,
    pub _chain: *mut _IO_FILE,
    pub _fileno: ::std::os::raw::c_int,
    pub _flags2: ::std::os::raw::c_int,
    pub _old_offset: __off_t,
    pub _cur_column: ::std::os::raw::c_ushort,
    pub _vtable_offset: ::std::os::raw::c_schar,
    pub _shortbuf: [::std::os::raw::c_char; 1usize],
    pub _lock: *mut _IO_lock_t,
    pub _offset: __off64_t,
    pub _codecvt: *mut _IO_codecvt,
    pub _wide_data: *mut _IO_wide_data,
    pub _freeres_list: *mut _IO_FILE,
    pub _freeres_buf: *mut ::std::os::raw::c_void,
    pub __pad5: usize,
    pub _mode: ::std::os::raw::c_int,
    pub _unused2: [::std::os::raw::c_char; 20usize],
}
#[test]
fn bindgen_test_layout__IO_FILE() {
    const UNINIT: ::std::mem::MaybeUninit<_IO_FILE> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_IO_FILE>(),
        216usize,
        concat!("Size of: ", stringify!(_IO_FILE))
    );
    assert_eq!(
        ::std::mem::align_of::<_IO_FILE>(),
        8usize,
        concat!("Alignment of ", stringify!(_IO_FILE))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._flags) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_flags)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._IO_read_ptr) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_read_ptr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._IO_read_end) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_read_end)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._IO_read_base) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_read_base)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._IO_write_base) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_write_base)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._IO_write_ptr) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_write_ptr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._IO_write_end) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_write_end)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._IO_buf_base) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_buf_base)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._IO_buf_end) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_buf_end)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._IO_save_base) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_save_base)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._IO_backup_base) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_backup_base)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._IO_save_end) as usize - ptr as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_save_end)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._markers) as usize - ptr as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_markers)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._chain) as usize - ptr as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_chain)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._fileno) as usize - ptr as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_fileno)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._flags2) as usize - ptr as usize },
        116usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_flags2)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._old_offset) as usize - ptr as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_old_offset)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._cur_column) as usize - ptr as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_cur_column)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._vtable_offset) as usize - ptr as usize },
        130usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_vtable_offset)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._shortbuf) as usize - ptr as usize },
        131usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_shortbuf)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._lock) as usize - ptr as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_lock)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._offset) as usize - ptr as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_offset)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._codecvt) as usize - ptr as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_codecvt)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._wide_data) as usize - ptr as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_wide_data)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._freeres_list) as usize - ptr as usize },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_freeres_list)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._freeres_buf) as usize - ptr as usize },
        176usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_freeres_buf)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__pad5) as usize - ptr as usize },
        184usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(__pad5)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._mode) as usize - ptr as usize },
        192usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_mode)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._unused2) as usize - ptr as usize },
        196usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_unused2)
        )
    );
}
pub type off_t = __off_t;
pub type fpos_t = __fpos_t;
extern "C" {
    pub static mut stdin: *mut FILE;
}
extern "C" {
    pub static mut stdout: *mut FILE;
}
extern "C" {
    pub static mut stderr: *mut FILE;
}
extern "C" {
    pub fn remove(__filename: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rename(
        __old: *const ::std::os::raw::c_char,
        __new: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn renameat(
        __oldfd: ::std::os::raw::c_int,
        __old: *const ::std::os::raw::c_char,
        __newfd: ::std::os::raw::c_int,
        __new: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn tmpfile() -> *mut FILE;
}
extern "C" {
    pub fn tmpnam(__s: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn tmpnam_r(__s: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn tempnam(
        __dir: *const ::std::os::raw::c_char,
        __pfx: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn fclose(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fflush(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fflush_unlocked(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fopen(
        __filename: *const ::std::os::raw::c_char,
        __modes: *const ::std::os::raw::c_char,
    ) -> *mut FILE;
}
extern "C" {
    pub fn freopen(
        __filename: *const ::std::os::raw::c_char,
        __modes: *const ::std::os::raw::c_char,
        __stream: *mut FILE,
    ) -> *mut FILE;
}
extern "C" {
    pub fn fdopen(__fd: ::std::os::raw::c_int, __modes: *const ::std::os::raw::c_char)
        -> *mut FILE;
}
extern "C" {
    pub fn fmemopen(
        __s: *mut ::std::os::raw::c_void,
        __len: usize,
        __modes: *const ::std::os::raw::c_char,
    ) -> *mut FILE;
}
extern "C" {
    pub fn open_memstream(
        __bufloc: *mut *mut ::std::os::raw::c_char,
        __sizeloc: *mut usize,
    ) -> *mut FILE;
}
extern "C" {
    pub fn setbuf(__stream: *mut FILE, __buf: *mut ::std::os::raw::c_char);
}
extern "C" {
    pub fn setvbuf(
        __stream: *mut FILE,
        __buf: *mut ::std::os::raw::c_char,
        __modes: ::std::os::raw::c_int,
        __n: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn setbuffer(__stream: *mut FILE, __buf: *mut ::std::os::raw::c_char, __size: usize);
}
extern "C" {
    pub fn setlinebuf(__stream: *mut FILE);
}
extern "C" {
    pub fn fprintf(
        __stream: *mut FILE,
        __format: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn printf(__format: *const ::std::os::raw::c_char, ...) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sprintf(
        __s: *mut ::std::os::raw::c_char,
        __format: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vfprintf(
        __s: *mut FILE,
        __format: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vprintf(
        __format: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vsprintf(
        __s: *mut ::std::os::raw::c_char,
        __format: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn snprintf(
        __s: *mut ::std::os::raw::c_char,
        __maxlen: ::std::os::raw::c_ulong,
        __format: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vsnprintf(
        __s: *mut ::std::os::raw::c_char,
        __maxlen: ::std::os::raw::c_ulong,
        __format: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vdprintf(
        __fd: ::std::os::raw::c_int,
        __fmt: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn dprintf(
        __fd: ::std::os::raw::c_int,
        __fmt: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fscanf(
        __stream: *mut FILE,
        __format: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn scanf(__format: *const ::std::os::raw::c_char, ...) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sscanf(
        __s: *const ::std::os::raw::c_char,
        __format: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}__isoc99_fscanf"]
    pub fn fscanf1(
        __stream: *mut FILE,
        __format: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}__isoc99_scanf"]
    pub fn scanf1(__format: *const ::std::os::raw::c_char, ...) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}__isoc99_sscanf"]
    pub fn sscanf1(
        __s: *const ::std::os::raw::c_char,
        __format: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vfscanf(
        __s: *mut FILE,
        __format: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vscanf(
        __format: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vsscanf(
        __s: *const ::std::os::raw::c_char,
        __format: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}__isoc99_vfscanf"]
    pub fn vfscanf1(
        __s: *mut FILE,
        __format: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}__isoc99_vscanf"]
    pub fn vscanf1(
        __format: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}__isoc99_vsscanf"]
    pub fn vsscanf1(
        __s: *const ::std::os::raw::c_char,
        __format: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fgetc(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getc(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getchar() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getc_unlocked(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getchar_unlocked() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fgetc_unlocked(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fputc(__c: ::std::os::raw::c_int, __stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn putc(__c: ::std::os::raw::c_int, __stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn putchar(__c: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fputc_unlocked(__c: ::std::os::raw::c_int, __stream: *mut FILE)
        -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn putc_unlocked(__c: ::std::os::raw::c_int, __stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn putchar_unlocked(__c: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getw(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn putw(__w: ::std::os::raw::c_int, __stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fgets(
        __s: *mut ::std::os::raw::c_char,
        __n: ::std::os::raw::c_int,
        __stream: *mut FILE,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn __getdelim(
        __lineptr: *mut *mut ::std::os::raw::c_char,
        __n: *mut usize,
        __delimiter: ::std::os::raw::c_int,
        __stream: *mut FILE,
    ) -> __ssize_t;
}
extern "C" {
    pub fn getdelim(
        __lineptr: *mut *mut ::std::os::raw::c_char,
        __n: *mut usize,
        __delimiter: ::std::os::raw::c_int,
        __stream: *mut FILE,
    ) -> __ssize_t;
}
extern "C" {
    pub fn getline(
        __lineptr: *mut *mut ::std::os::raw::c_char,
        __n: *mut usize,
        __stream: *mut FILE,
    ) -> __ssize_t;
}
extern "C" {
    pub fn fputs(__s: *const ::std::os::raw::c_char, __stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn puts(__s: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ungetc(__c: ::std::os::raw::c_int, __stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fread(
        __ptr: *mut ::std::os::raw::c_void,
        __size: ::std::os::raw::c_ulong,
        __n: ::std::os::raw::c_ulong,
        __stream: *mut FILE,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn fwrite(
        __ptr: *const ::std::os::raw::c_void,
        __size: ::std::os::raw::c_ulong,
        __n: ::std::os::raw::c_ulong,
        __s: *mut FILE,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn fread_unlocked(
        __ptr: *mut ::std::os::raw::c_void,
        __size: usize,
        __n: usize,
        __stream: *mut FILE,
    ) -> usize;
}
extern "C" {
    pub fn fwrite_unlocked(
        __ptr: *const ::std::os::raw::c_void,
        __size: usize,
        __n: usize,
        __stream: *mut FILE,
    ) -> usize;
}
extern "C" {
    pub fn fseek(
        __stream: *mut FILE,
        __off: ::std::os::raw::c_long,
        __whence: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ftell(__stream: *mut FILE) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn rewind(__stream: *mut FILE);
}
extern "C" {
    pub fn fseeko(
        __stream: *mut FILE,
        __off: __off_t,
        __whence: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ftello(__stream: *mut FILE) -> __off_t;
}
extern "C" {
    pub fn fgetpos(__stream: *mut FILE, __pos: *mut fpos_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fsetpos(__stream: *mut FILE, __pos: *const fpos_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn clearerr(__stream: *mut FILE);
}
extern "C" {
    pub fn feof(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ferror(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn clearerr_unlocked(__stream: *mut FILE);
}
extern "C" {
    pub fn feof_unlocked(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ferror_unlocked(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn perror(__s: *const ::std::os::raw::c_char);
}
extern "C" {
    pub static mut sys_nerr: ::std::os::raw::c_int;
}
extern "C" {
    pub static sys_errlist: [*const ::std::os::raw::c_char; 0usize];
}
extern "C" {
    pub fn fileno(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fileno_unlocked(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn popen(
        __command: *const ::std::os::raw::c_char,
        __modes: *const ::std::os::raw::c_char,
    ) -> *mut FILE;
}
extern "C" {
    pub fn pclose(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ctermid(__s: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn flockfile(__stream: *mut FILE);
}
extern "C" {
    pub fn ftrylockfile(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn funlockfile(__stream: *mut FILE);
}
extern "C" {
    pub fn __uflow(arg1: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __overflow(arg1: *mut FILE, arg2: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
#[doc = "< Critical log level"]
pub const doca_log_level_DOCA_LOG_LEVEL_CRIT: doca_log_level = 20;
#[doc = "< Error log level"]
pub const doca_log_level_DOCA_LOG_LEVEL_ERROR: doca_log_level = 30;
#[doc = "< Warning log level"]
pub const doca_log_level_DOCA_LOG_LEVEL_WARNING: doca_log_level = 40;
#[doc = "< Info log level"]
pub const doca_log_level_DOCA_LOG_LEVEL_INFO: doca_log_level = 50;
#[doc = "< Debug log level"]
pub const doca_log_level_DOCA_LOG_LEVEL_DEBUG: doca_log_level = 60;
#[doc = " @brief log levels"]
pub type doca_log_level = ::std::os::raw::c_uint;
#[doc = " @brief logging backend"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct doca_logger_backend {
    _unused: [u8; 0],
}
#[doc = " @brief logging backend flush() handler"]
pub type log_flush_callback =
    ::std::option::Option<unsafe extern "C" fn(buffer: *mut ::std::os::raw::c_char)>;
extern "C" {
    #[doc = " @brief Redirect the logger to a different stream.\n\n Dynamically change the logger stream of the default logger backend. The default\n stream is stderr.\n\n @param[in] stream\n Pointer to the stream.\n @return\n DOCA error code."]
    pub fn doca_log_stream_redirect(stream: *mut FILE) -> doca_error_t;
}
extern "C" {
    #[doc = " @brief Get the timespan of the rate-limit bucket.\n\n @return\n Time (in seconds) of the rate-limit bucket."]
    pub fn doca_log_get_bucket_time() -> u16;
}
extern "C" {
    #[doc = " @brief Set the timespan of the rate-limit bucket.\n\n @param[in] bucket_time\n Time (in seconds) for the rate-limit bucket."]
    pub fn doca_log_set_bucket_time(bucket_time: u16);
}
extern "C" {
    #[doc = " @brief Get the quantity of the rate-limit bucket.\n\n @return\n Maximal number of log events for a rate-limit bucket."]
    pub fn doca_log_get_quantity() -> u16;
}
extern "C" {
    #[doc = " @brief Set the quantity of the rate-limit bucket.\n\n @param quantity\n Maximal number of log events for a rate-limit bucket."]
    pub fn doca_log_set_quantity(quantity: u16);
}
extern "C" {
    #[doc = " @brief Set the log level of a specific logger backend.\n\n Dynamically change the log level of the given logger backend, any log under this\n level will be shown.\n\n @param[in] logger\n Logger backend to update.\n @param[in] level\n Log level enum DOCA_LOG_LEVEL.\n @return\n DOCA error code."]
    pub fn doca_log_backend_level_set(logger: *mut doca_logger_backend, level: u32)
        -> doca_error_t;
}
extern "C" {
    #[doc = " @brief Set the log level of the default logger backend.\n\n Dynamically change the log level of the default logger backend, any log under this\n level will be shown.\n\n @param[in] level\n Log level enum DOCA_LOG_LEVEL.\n @return\n DOCA error code."]
    pub fn doca_log_global_level_set(level: u32) -> doca_error_t;
}
extern "C" {
    #[doc = " @brief Get the log level of the default logger backend.\n\n Dynamically query for the log level of the default logger backend, any log under this\n level will be shown.\n\n @return\n Log level enum DOCA_LOG_LEVEL."]
    pub fn doca_log_global_level_get() -> u32;
}
extern "C" {
    #[doc = " @brief Register a log source.\n\n Will return the identifier associated with the log source. Log source name will be shown\n in the logs.\n\n @note Recommended to only be used via DOCA_LOG_REGISTER.\n\n @param[in] source_name\n The string identifying the log source. Should be in an heirarchic form (i.e. DPI::Parser).\n @param[out] source\n Source identifier that was allocated to this log source name (only valid if no error occurred).\n @return\n DOCA error code."]
    pub fn doca_log_source_register(
        source_name: *const ::std::os::raw::c_char,
        source: *mut ::std::os::raw::c_int,
    ) -> doca_error_t;
}
extern "C" {
    #[doc = " @brief Destroy a log source.\n\n Destroys a given log source as part of the teardown process of the running program.\n\n @note Used automatically via DOCA_LOG_REGISTER, not recommended to call it directly.\n\n @param[in] source\n The source identifier of source to be destroyed, as allocated by doca_log_source_register.\n @return\n DOCA error code."]
    pub fn doca_log_source_destroy(source: ::std::os::raw::c_int) -> doca_error_t;
}
extern "C" {
    #[doc = " @brief Register a new rate bucket.\n\n Will return the identifier associated with the new bucket.\n\n @param[in] source\n The log source identifier defined by doca_log_source_register.\n @param[out] bucket\n Bucket identifier that was allocated to this log source (only valid if no error occurred).\n @return\n DOCA error code."]
    pub fn doca_log_rate_bucket_register(
        source: ::std::os::raw::c_int,
        bucket: *mut ::std::os::raw::c_int,
    ) -> doca_error_t;
}
extern "C" {
    #[doc = " @brief Create a logging backend with a FILE* stream.\n\n Creates a new logging backend that will be added on top of the default logger.\n\n @param[in] fptr\n The FILE * for the logger's stream.\n @param[out] backend\n Logging backend that wraps the given fptr (only valid if no error occurred).\n @return\n DOCA error code."]
    pub fn doca_log_create_file_backend(
        fptr: *mut FILE,
        backend: *mut *mut doca_logger_backend,
    ) -> doca_error_t;
}
extern "C" {
    #[doc = " @brief Create a logging backend with an fd stream.\n\n Creates a new logging backend that will be added on top of the default logger.\n\n @param[in] fd\n The file descriptor (int) for the logger's backend.\n @param[out] backend\n Logging backend that wraps the given fd (only valid if no error occurred).\n @return\n DOCA error code."]
    pub fn doca_log_create_fd_backend(
        fd: ::std::os::raw::c_int,
        backend: *mut *mut doca_logger_backend,
    ) -> doca_error_t;
}
extern "C" {
    #[doc = " @brief Create a logging backend with a char buffer stream.\n\n Creates a new logging backend that will be added on top of the default logger. The\n logger will write each log record at the beginning of this buffer.\n\n @param[in] buffer\n The char buffer (char *) for the logger's stream.\n @param[in] capacity\n Maximal amount of chars that could be written to the stream.\n @param[in] handler\n Handler to be called when the log record should be flushed from the stream.\n @param[out] backend\n Logging backend that wraps the given buffer (only valid if no error occurred).\n @return\n DOCA error code."]
    pub fn doca_log_create_buffer_backend(
        buffer: *mut ::std::os::raw::c_char,
        capacity: usize,
        handler: log_flush_callback,
        backend: *mut *mut doca_logger_backend,
    ) -> doca_error_t;
}
extern "C" {
    #[doc = " @brief Create a logging backend with a syslog output.\n\n Creates a new logging backend that will be added on top of the default logger.\n\n @param[in] name\n The syslog name for the logger's backend.\n @param[out] backend\n Logging backend that exposes the desired syslog functionality (only valid if no error occurred).\n @return\n DOCA error code."]
    pub fn doca_log_create_syslog_backend(
        name: *const ::std::os::raw::c_char,
        backend: *mut *mut doca_logger_backend,
    ) -> doca_error_t;
}
extern "C" {
    #[doc = " @brief Generates a log message.\n\n The log will be shown in the doca_log_stream_redirect (see default).\n This should not be used, please prefer using DOCA_LOG...\n\n @param[in] level\n Log level enum DOCA_LOG_LEVEL.\n @param[in] source\n The log source identifier defined by doca_log_source_register.\n @param[in] line\n The line number this log originated from.\n @param[in] format\n printf(3) arguments, format and variables.\n @return\n DOCA error code."]
    pub fn doca_log(
        level: u32,
        source: ::std::os::raw::c_int,
        line: ::std::os::raw::c_int,
        format: *const ::std::os::raw::c_char,
        ...
    ) -> doca_error_t;
}
extern "C" {
    #[doc = " @brief Generates a log message for DLOG operations.\n\n The log will be shown in the doca_log_stream_redirect (see default).\n @note This function is thread safe.\n\n @param[in] level\n Log level enum DOCA_LOG_LEVEL.\n @param[in] source\n The log source identifier defined by doca_log_source_register.\n @param[in] line\n The line number this log originated from.\n @param[in] format\n printf(3) arguments, format and variables.\n @return\n DOCA error code."]
    pub fn doca_log_developer(
        level: u32,
        source: ::std::os::raw::c_int,
        line: ::std::os::raw::c_int,
        format: *const ::std::os::raw::c_char,
        ...
    ) -> doca_error_t;
}
extern "C" {
    #[doc = " @brief Generates a log message with rate limit.\n\n The log will be shown in the doca_log_stream_redirect (see default).\n This should not be used, please prefer using DOCA_LOG_RATE_LIMIT...\n\n @param level\n Log level enum DOCA_LOG_LEVEL.\n @param source\n The log source identifier defined by doca_log_source_register.\n @param line\n The line number this log originated from.\n @param bucket\n The bucket identifier defined by doca_log_rate_bucket_register.\n @param format\n printf(3) arguments, format and variables."]
    pub fn doca_log_rate_limit(
        level: u32,
        source: ::std::os::raw::c_int,
        line: ::std::os::raw::c_int,
        bucket: ::std::os::raw::c_int,
        format: *const ::std::os::raw::c_char,
        ...
    ) -> doca_error_t;
}
pub const dma_copy_mode_DMA_COPY_MODE_HOST: dma_copy_mode = 0;
pub const dma_copy_mode_DMA_COPY_MODE_DPU: dma_copy_mode = 1;
pub type dma_copy_mode = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cc_msg_dma_direction {
    pub file_in_host: bool,
    pub file_size: u32,
}
#[test]
fn bindgen_test_layout_cc_msg_dma_direction() {
    const UNINIT: ::std::mem::MaybeUninit<cc_msg_dma_direction> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<cc_msg_dma_direction>(),
        8usize,
        concat!("Size of: ", stringify!(cc_msg_dma_direction))
    );
    assert_eq!(
        ::std::mem::align_of::<cc_msg_dma_direction>(),
        4usize,
        concat!("Alignment of ", stringify!(cc_msg_dma_direction))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).file_in_host) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cc_msg_dma_direction),
            "::",
            stringify!(file_in_host)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).file_size) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(cc_msg_dma_direction),
            "::",
            stringify!(file_size)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cc_msg_dma_status {
    pub is_success: bool,
}
#[test]
fn bindgen_test_layout_cc_msg_dma_status() {
    const UNINIT: ::std::mem::MaybeUninit<cc_msg_dma_status> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<cc_msg_dma_status>(),
        1usize,
        concat!("Size of: ", stringify!(cc_msg_dma_status))
    );
    assert_eq!(
        ::std::mem::align_of::<cc_msg_dma_status>(),
        1usize,
        concat!("Alignment of ", stringify!(cc_msg_dma_status))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).is_success) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cc_msg_dma_status),
            "::",
            stringify!(is_success)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct dma_copy_cfg {
    pub mode: dma_copy_mode,
    pub file_path: [::std::os::raw::c_char; 128usize],
    pub cc_dev_pci_addr: [::std::os::raw::c_char; 8usize],
    pub cc_dev_rep_pci_addr: [::std::os::raw::c_char; 8usize],
    pub is_file_found_locally: bool,
    pub file_size: u32,
}
#[test]
fn bindgen_test_layout_dma_copy_cfg() {
    const UNINIT: ::std::mem::MaybeUninit<dma_copy_cfg> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<dma_copy_cfg>(),
        156usize,
        concat!("Size of: ", stringify!(dma_copy_cfg))
    );
    assert_eq!(
        ::std::mem::align_of::<dma_copy_cfg>(),
        4usize,
        concat!("Alignment of ", stringify!(dma_copy_cfg))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).mode) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(dma_copy_cfg),
            "::",
            stringify!(mode)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).file_path) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(dma_copy_cfg),
            "::",
            stringify!(file_path)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).cc_dev_pci_addr) as usize - ptr as usize },
        132usize,
        concat!(
            "Offset of field: ",
            stringify!(dma_copy_cfg),
            "::",
            stringify!(cc_dev_pci_addr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).cc_dev_rep_pci_addr) as usize - ptr as usize },
        140usize,
        concat!(
            "Offset of field: ",
            stringify!(dma_copy_cfg),
            "::",
            stringify!(cc_dev_rep_pci_addr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).is_file_found_locally) as usize - ptr as usize },
        148usize,
        concat!(
            "Offset of field: ",
            stringify!(dma_copy_cfg),
            "::",
            stringify!(is_file_found_locally)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).file_size) as usize - ptr as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(dma_copy_cfg),
            "::",
            stringify!(file_size)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct core_state {
    pub dev: *mut doca_dev,
    pub mmap: *mut doca_mmap,
    pub buf_inv: *mut doca_buf_inventory,
    pub ctx: *mut doca_ctx,
    pub dma_ctx: *mut doca_dma,
    pub workq: *mut doca_workq,
}
#[test]
fn bindgen_test_layout_core_state() {
    const UNINIT: ::std::mem::MaybeUninit<core_state> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<core_state>(),
        48usize,
        concat!("Size of: ", stringify!(core_state))
    );
    assert_eq!(
        ::std::mem::align_of::<core_state>(),
        8usize,
        concat!("Alignment of ", stringify!(core_state))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).dev) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(core_state),
            "::",
            stringify!(dev)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).mmap) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(core_state),
            "::",
            stringify!(mmap)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).buf_inv) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(core_state),
            "::",
            stringify!(buf_inv)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ctx) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(core_state),
            "::",
            stringify!(ctx)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).dma_ctx) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(core_state),
            "::",
            stringify!(dma_ctx)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).workq) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(core_state),
            "::",
            stringify!(workq)
        )
    );
}
extern "C" {
    pub fn register_dma_copy_params() -> doca_error_t;
}
extern "C" {
    pub fn init_cc(
        cfg: *mut dma_copy_cfg,
        ep: *mut *mut doca_comm_channel_ep_t,
        dev: *mut *mut doca_dev,
        dev_rep: *mut *mut doca_dev_rep,
    ) -> doca_error_t;
}
extern "C" {
    pub fn destroy_cc(
        ep: *mut doca_comm_channel_ep_t,
        peer: *mut doca_comm_channel_addr_t,
        dev: *mut doca_dev,
        dev_rep: *mut doca_dev_rep,
    );
}
extern "C" {
    pub fn open_dma_device(dev: *mut *mut doca_dev) -> doca_error_t;
}
extern "C" {
    pub fn create_core_objs(state: *mut core_state, mode: dma_copy_mode) -> doca_error_t;
}
extern "C" {
    pub fn init_core_objs(state: *mut core_state, cfg: *mut dma_copy_cfg) -> doca_error_t;
}
extern "C" {
    pub fn destroy_core_objs(state: *mut core_state, cfg: *mut dma_copy_cfg);
}
extern "C" {
    pub fn host_start_dma_copy(
        dma_cfg: *mut dma_copy_cfg,
        core_state: *mut core_state,
        ep: *mut doca_comm_channel_ep_t,
        peer_addr: *mut *mut doca_comm_channel_addr_t,
    ) -> doca_error_t;
}
extern "C" {
    pub fn dpu_start_dma_copy(
        dma_cfg: *mut dma_copy_cfg,
        core_state: *mut core_state,
        ep: *mut doca_comm_channel_ep_t,
        peer_addr: *mut *mut doca_comm_channel_addr_t,
    ) -> doca_error_t;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __locale_data {
    pub _address: u8,
}
pub type __builtin_va_list = [__va_list_tag; 1usize];
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __va_list_tag {
    pub gp_offset: ::std::os::raw::c_uint,
    pub fp_offset: ::std::os::raw::c_uint,
    pub overflow_arg_area: *mut ::std::os::raw::c_void,
    pub reg_save_area: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout___va_list_tag() {
    const UNINIT: ::std::mem::MaybeUninit<__va_list_tag> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__va_list_tag>(),
        24usize,
        concat!("Size of: ", stringify!(__va_list_tag))
    );
    assert_eq!(
        ::std::mem::align_of::<__va_list_tag>(),
        8usize,
        concat!("Alignment of ", stringify!(__va_list_tag))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).gp_offset) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__va_list_tag),
            "::",
            stringify!(gp_offset)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).fp_offset) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(__va_list_tag),
            "::",
            stringify!(fp_offset)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).overflow_arg_area) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__va_list_tag),
            "::",
            stringify!(overflow_arg_area)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).reg_save_area) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__va_list_tag),
            "::",
            stringify!(reg_save_area)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct doca_mmap {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct doca_buf_inventory {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct doca_ctx {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct doca_dma {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct doca_workq {
    pub _address: u8,
}
